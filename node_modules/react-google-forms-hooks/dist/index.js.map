{"version":3,"file":"index.js","sources":["../src/hooks/utils/getFieldFromContext.ts","../src/hooks/useGoogleFormContext.tsx","../src/hooks/utils/useCustomOptionField.ts","../src/scripts/submitToGoogleForms.ts","../src/hooks/useGoogleForm.ts","../src/hooks/useRadioInput.ts","../src/hooks/useCheckboxInput.ts","../src/hooks/utils/useTextInput.ts","../src/hooks/useShortAnswerInput.ts","../src/hooks/useLongAnswerInput.ts","../src/hooks/utils/useGridInput.ts","../src/hooks/useCheckboxGridInput.ts","../src/hooks/useRadioGridInput.ts","../src/hooks/useDropdownInput.ts","../src/hooks/useLinearInput.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/scripts/googleFormsToJson.ts"],"sourcesContent":["import { UseGoogleFormReturn, FieldTypes } from '../../types'\n\nexport default (\n  context: UseGoogleFormReturn | null,\n  id: string,\n  type: FieldTypes\n) => {\n  if (context === null) {\n    throw new Error('You need to wrap your form with a GoogleFormProvider')\n  }\n\n  const field = context.getField(id)\n\n  if (field.type !== type) {\n    throw new Error(`Field with id ${field.id} is not of type ${type}`)\n  }\n\n  return field\n}\n","import * as React from 'react'\nimport { UseGoogleFormReturn } from '../types'\n\nconst GoogleFormContext = React.createContext<UseGoogleFormReturn | null>(null)\nexport const useGoogleFormContext = () => React.useContext(GoogleFormContext)\n\nexport const GoogleFormProvider = ({\n  children,\n  ...other\n}: {\n  children: React.ReactNode\n}) => {\n  return (\n    <GoogleFormContext.Provider value={other as UseGoogleFormReturn}>\n      {children}\n    </GoogleFormContext.Provider>\n  )\n}\n","import { useState, useEffect } from 'react'\nimport slugify from 'slugify'\n\nimport {\n  UseCustomOptionReturn,\n  Option,\n  BaseField,\n  UseCustomOptionField,\n  CustomOptionField\n} from '../../types'\nimport getFieldFromContext from './getFieldFromContext'\nimport { useGoogleFormContext } from '../useGoogleFormContext'\nimport { RegisterOptions } from 'react-hook-form'\n\nexport const OTHER_OPTION = '__other_option__'\nexport const OTHER_OPTION_RESPONSE = 'other_option_response'\n\nexport const buildCustomFieldId = (id: string) => {\n  return `${id}-${OTHER_OPTION_RESPONSE}`\n}\n\nexport default (\n  id: string,\n  type: 'CHECKBOX' | 'RADIO'\n): UseCustomOptionField => {\n  const context = useGoogleFormContext()\n  const field = getFieldFromContext(context, id, type) as CustomOptionField\n\n  const [isCustomOptionSelected, setIsCustomOptionSelected] =\n    useState<boolean>(false)\n  const [customInputRequired, setCustomInputRequired] = useState<boolean>(false)\n\n  const register = (options?: RegisterOptions) =>\n    context!.register(id, { required: field.required, ...options })\n\n  const currentValue = context!.watch(id)\n\n  useEffect(() => {\n    if (field.type === 'RADIO') {\n      const isCustomOptionSelected =\n        currentValue && currentValue === OTHER_OPTION\n      setCustomInputRequired(field.required && isCustomOptionSelected)\n      setIsCustomOptionSelected(isCustomOptionSelected)\n    } else {\n      const isCustomOptionSelected =\n        currentValue &&\n        currentValue.length === 1 &&\n        currentValue.includes(OTHER_OPTION)\n      setCustomInputRequired(field.required && isCustomOptionSelected)\n      setIsCustomOptionSelected(isCustomOptionSelected)\n    }\n  }, [currentValue, customInputRequired])\n\n  const nonCustomOptions = field.options.filter(\n    (o) => !o.custom\n  ) as Array<Option>\n\n  const buildId = (value: string) => {\n    return `${id}-${slugify(value)}`\n  }\n\n  const buildOptionRegister = (o: Option) => {\n    const id = buildId(o.label)\n    const registerOption = (options: RegisterOptions) => ({\n      ...register({ ...options }),\n      value: o.label\n    })\n\n    return {\n      ...o,\n      id,\n      registerOption\n    }\n  }\n\n  const result = {\n    options: nonCustomOptions.map(buildOptionRegister)\n  } as UseCustomOptionReturn\n\n  const customOption = field.options.find((o) => o.custom) as Option\n  if (customOption) {\n    const id = buildId(OTHER_OPTION)\n    const registerOption = (options = {}) => ({\n      ...register({ ...options }),\n      value: OTHER_OPTION\n    })\n\n    const customOptionId = buildCustomFieldId(id)\n\n    const registerCustomInput = (options = {}) => {\n      return context!.register(customOptionId, {\n        required: customInputRequired,\n        ...options\n      })\n    }\n\n    const error = context!.formState.errors[customOptionId]\n\n    result.customOption = {\n      ...customOption,\n      id,\n      registerOption,\n      registerCustomInput,\n      error\n    }\n  }\n\n  const error = context!.formState.errors[field.id]\n\n  return {\n    ...(field as BaseField),\n    ...result,\n    error,\n    isCustomOptionSelected\n  }\n}\n","import fetch from 'isomorphic-unfetch'\nimport { GoogleForm } from '../types'\nimport {\n  OTHER_OPTION,\n  OTHER_OPTION_RESPONSE\n} from '../hooks/utils/useCustomOptionField'\n\nexport const GOOGLE_FORMS_URL = 'https://docs.google.com/forms/d'\n\nexport const formatQuestionName = (id: string) => {\n  if (id.includes(OTHER_OPTION_RESPONSE)) {\n    return `entry.${id.replace(\n      `-${OTHER_OPTION}-${OTHER_OPTION_RESPONSE}`,\n      ''\n    )}.${OTHER_OPTION_RESPONSE}`\n  }\n\n  return `entry.${id}`\n}\n\nexport const submitToGoogleForms = async (\n  form: GoogleForm,\n  formData: object\n): Promise<boolean> => {\n  const urlParams = new URLSearchParams()\n  Object.keys(formData).forEach((key) => {\n    if (formData[key]) {\n      if (formData[key].constructor === Array) {\n        formData[key].forEach((answer: string) => {\n          urlParams.append(formatQuestionName(key), answer)\n        })\n      } else {\n        urlParams.append(formatQuestionName(key), formData[key])\n      }\n    }\n  })\n\n  const fetchedResult = await fetch(\n    `${GOOGLE_FORMS_URL}/${\n      form.action\n    }/formResponse?submit=Submit&${urlParams.toString()}`,\n    {\n      method: 'GET',\n      mode: 'no-cors',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      }\n    }\n  )\n\n  const wasSuccessful =\n    fetchedResult.ok &&\n    fetchedResult.status < 300 &&\n    fetchedResult.status >= 200\n\n  return wasSuccessful\n}\n","import { useForm } from 'react-hook-form'\nimport { GoogleForm, UseGoogleFormReturn } from '../types'\nimport { submitToGoogleForms } from '../scripts/submitToGoogleForms'\n\nconst resolveField = (id: string, form: GoogleForm) => {\n  const fieldIndex = form.fieldsOrder[id]\n\n  if (fieldIndex === undefined) {\n    throw new Error(`Field with id ${id} wasn't found in your form`)\n  }\n\n  const field = form.fields[fieldIndex]\n  return field\n}\n\nexport const useGoogleForm = ({ form }: { form: GoogleForm }) => {\n  const methods = useForm() as UseGoogleFormReturn\n\n  methods.getField = (id: string) => resolveField(id, form)\n\n  methods.submitToGoogleForms = (formData) =>\n    submitToGoogleForms(form, formData)\n\n  return methods\n}\n","import useCustomOptionField from './utils/useCustomOptionField'\nimport { UseCustomOptionField } from '../types'\n\nexport const useRadioInput = (id: string): UseCustomOptionField => {\n  return useCustomOptionField(id, 'RADIO')\n}\n","import useCustomOptionField from './utils/useCustomOptionField'\nimport { UseCustomOptionField } from '../types'\n\nexport const useCheckboxInput = (id: string): UseCustomOptionField => {\n  return useCustomOptionField(id, 'CHECKBOX')\n}\n","import { RegisterOptions } from 'react-hook-form'\n\nimport { UseTextFieldReturn, TextField } from '../../types'\nimport { useGoogleFormContext } from '../useGoogleFormContext'\nimport getFieldFromContext from './getFieldFromContext'\n\nexport default (\n  id: string,\n  fieldType: 'LONG_ANSWER' | 'SHORT_ANSWER'\n): UseTextFieldReturn => {\n  const context = useGoogleFormContext()\n\n  const field = getFieldFromContext(context, id, fieldType) as TextField\n\n  const error = context!.formState.errors[field.id]\n\n  const register = (options?: RegisterOptions) =>\n    context!.register(id, { required: field.required, ...options })\n\n  return { ...field, register, error }\n}\n","import useTextInput from './utils/useTextInput'\n\nexport const useShortAnswerInput = (id: string) => {\n  return useTextInput(id, 'SHORT_ANSWER')\n}\n","import useTextInput from './utils/useTextInput'\n\nexport const useLongAnswerInput = (id: string) => {\n  return useTextInput(id, 'LONG_ANSWER')\n}\n","import { useEffect, useState } from 'react'\nimport { RegisterOptions } from 'react-hook-form'\nimport slugify from 'slugify'\n\nimport { useGoogleFormContext } from '../useGoogleFormContext'\nimport getFieldFromContext from './getFieldFromContext'\nimport {\n  UseGridFieldReturn,\n  GridField,\n  RenderLineFunction,\n  RenderColumnFunction,\n  GridErrors\n} from '../../types'\n\nexport default (\n  id: string,\n  type: 'RADIO_GRID' | 'CHECKBOX_GRID'\n): UseGridFieldReturn => {\n  const context = useGoogleFormContext()\n  const [errors, setErrors] = useState<GridErrors | undefined>(undefined)\n\n  const field = getFieldFromContext(context, id, type) as GridField\n\n  const buildId = (lineId: string, value: string) => {\n    return `${id}-${lineId}-${slugify(value)}`\n  }\n\n  useEffect(() => {\n    const newErrors: GridErrors = field.lines.reduce((acc: GridErrors, l) => {\n      const fieldError = context!.formState.errors[l.id]\n      if (fieldError) {\n        acc[l.id] = fieldError\n      }\n      return acc\n    }, {})\n\n    if (Object.keys(newErrors).length > 0) {\n      setErrors(newErrors)\n    } else {\n      setErrors(undefined)\n    }\n  }, [context!.formState.errors])\n\n  const renderGrid = (render: RenderLineFunction): JSX.Element[] => {\n    return field.lines.map((l) => {\n      const registerLine = (options?: RegisterOptions) =>\n        context!.register(l.id, { required: field.required, ...options })\n\n      const renderColumns = (render: RenderColumnFunction): JSX.Element[] => {\n        return field.columns.map((c) => {\n          const id = buildId(l.id, c.label)\n          const registerColumn = (options?: RegisterOptions) => ({\n            ...registerLine(options),\n            value: c.label\n          })\n\n          return render({ ...c, registerColumn, id })\n        })\n      }\n\n      return render({ ...l, renderColumns })\n    })\n  }\n\n  return { ...field, renderGrid, errors }\n}\n","import useGridInput from './utils/useGridInput'\n\nexport const useCheckboxGridInput = (id: string) => {\n  return useGridInput(id, 'CHECKBOX_GRID')\n}\n","import useGridInput from './utils/useGridInput'\n\nexport const useRadioGridInput = (id: string) => {\n  return useGridInput(id, 'RADIO_GRID')\n}\n","import slugify from 'slugify'\n\nimport { useGoogleFormContext } from './useGoogleFormContext'\nimport getFieldFromContext from './utils/getFieldFromContext'\nimport { UseDropdownReturn, DropdownField } from '../types'\nimport { RegisterOptions } from 'react-hook-form'\n\nexport const useDropdownInput = (id: string): UseDropdownReturn => {\n  const context = useGoogleFormContext()\n\n  const field = getFieldFromContext(context, id, 'DROPDOWN') as DropdownField\n\n  const register = (options?: RegisterOptions) =>\n    context!.register(id, { required: field.required, ...options })\n\n  const error = context!.formState.errors[field.id]\n\n  const buildId = (value: string) => {\n    return `${field.id}-${slugify(value)}`\n  }\n\n  const options = field.options.map((o) => {\n    const id = buildId(o.label)\n    return {\n      ...o,\n      id\n    }\n  })\n\n  return { ...field, options, register, error }\n}\n","import slugify from 'slugify'\nimport { RegisterOptions } from 'react-hook-form'\n\nimport { useGoogleFormContext } from './useGoogleFormContext'\nimport getFieldFromContext from './utils/getFieldFromContext'\nimport { UseLinearInputReturn, LinearField } from '../types'\n\nexport const useLinearInput = (id: string): UseLinearInputReturn => {\n  const context = useGoogleFormContext()\n\n  const field = getFieldFromContext(context, id, 'LINEAR') as LinearField\n\n  const register = (options?: RegisterOptions) =>\n    context!.register(id, { required: field.required, ...options })\n\n  const buildId = (value: string) => {\n    return `${field.id}-${slugify(value)}`\n  }\n\n  const error = context!.formState.errors[field.id]\n\n  const options = field.options.map((o) => {\n    const id = buildId(o.label)\n    const registerOption = (options?: RegisterOptions) => ({\n      ...register(options),\n      value: o.label\n    })\n\n    return {\n      ...o,\n      id,\n      registerOption\n    }\n  })\n\n  return { ...field, options, error }\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import cheerio from 'cheerio'\nimport fetch from 'isomorphic-unfetch'\n\nimport {\n  Column,\n  CustomizableOption,\n  Field,\n  FieldsOrder,\n  GoogleForm,\n  Line,\n  Option\n} from '../types/form'\n\ntype FormData = {\n  formData: object\n  fbzx: string\n}\n\nconst toBool = (n: number): boolean => n === 1\n\nconst toString = (n: number): string => `${n}`\n\nconst assertValidUrl = (formUrl: string): void => {\n  const googleFormsHosts = ['docs.google.com', 'forms.gle']\n  const url = new URL(formUrl)\n\n  if (!googleFormsHosts.includes(url.host)) {\n    throw new Error(\n      `Invalid google forms host. ${\n        url.host\n      } is expected to be ${googleFormsHosts\n        .join(', ')\n        .replace(/, ([^,]*)$/, ' or $1')}.`\n    )\n  }\n\n  if (url.host === googleFormsHosts[0] && !url.pathname.endsWith('/viewform')) {\n    throw new Error(`Please use the form's public URL.`)\n  }\n}\n\nconst getFormHtml = async (formUrl: string) => {\n  const response = await fetch(formUrl)\n  const html = await response.text()\n  return html\n}\n\nconst extractFormData = (html: string): FormData => {\n  const $ = cheerio.load(html)\n  const fbzx = $('[name=\"fbzx\"]').attr('value')\n\n  if (!fbzx) {\n    throw new Error(`Invalid form. Couldn't find fbzx field.`)\n  }\n\n  const scriptStringIdentifier = 'var FB_PUBLIC_LOAD_DATA_ ='\n  let scriptHtml = $('script')\n    .filter((_, el) => {\n      return $(el).html()!.includes(scriptStringIdentifier)\n    })\n    .first()\n    .html()\n\n  if (!scriptHtml) {\n    throw new Error(`Invalid form. Couldn't find script tag.`)\n  }\n\n  scriptHtml = scriptHtml.slice(0, -1)\n  scriptHtml = scriptHtml.replace(scriptStringIdentifier, '')\n\n  const formDataRaw = JSON.parse(scriptHtml)\n\n  return { formData: formDataRaw, fbzx }\n}\n\nconst parseGridMultiSelect = (rawField: Array<object>): 1 | 0 => {\n  const firstLine = rawField[4][0]\n  const canSelectMultiple = firstLine[11][0]\n\n  return canSelectMultiple\n}\n\nconst parseFieldType = (rawField: Array<object>, fieldId: number) => {\n  const fieldTypes = [\n    'SHORT_ANSWER',\n    'LONG_ANSWER',\n    'RADIO',\n    'DROPDOWN',\n    'CHECKBOX',\n    'LINEAR'\n  ] as const\n\n  if (fieldId === 7) {\n    if (parseGridMultiSelect(rawField) === 1) {\n      return 'CHECKBOX_GRID'\n    } else {\n      return 'RADIO_GRID'\n    }\n  }\n  if (fieldId === 9) {\n    return 'DATE'\n  }\n\n  return fieldTypes[fieldId]\n}\n\nconst parseOptions = (options: Array<object>): Array<Option> => {\n  return options.map((rawOption) => ({ label: rawOption[0] }))\n}\n\nconst parseCustomizableOptions = (\n  options: Array<object>\n): Array<CustomizableOption> => {\n  return options.map((rawOption) => ({\n    label: rawOption[0],\n    custom: rawOption[4] === 1\n  }))\n}\n\nconst flattenArray = (array: Array<Array<string>>): Array<Option | Column> => {\n  return array.map((item) => ({ label: item[0] }))\n}\n\nconst parseLines = (lines: Array<any>): Array<Line> => {\n  return lines.map((rawLine) => {\n    const line = {} as Line\n    line.id = toString(rawLine[0])\n    line.label = rawLine[3][0]\n    return line\n  })\n}\n\nconst parseField = (rawField: Array<any>): Field => {\n  const field = {} as Field\n\n  field.label = rawField[1]\n  field.description = rawField[2]\n\n  const fieldId = rawField[3]\n  field.type = parseFieldType(rawField, fieldId)\n\n  switch (field.type) {\n    case 'SHORT_ANSWER':\n    case 'LONG_ANSWER': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      field.required = toBool(fieldInfo[2])\n      break\n    }\n    case 'CHECKBOX':\n    case 'RADIO': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      field.options = parseCustomizableOptions(fieldInfo[1])\n      field.required = toBool(fieldInfo[2])\n      break\n    }\n    case 'DROPDOWN': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      field.options = parseOptions(fieldInfo[1])\n      field.required = toBool(fieldInfo[2])\n      break\n    }\n    case 'LINEAR': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      const [labelFirst, labelLast] = fieldInfo[3]\n      field.legend = { labelFirst, labelLast }\n      field.options = flattenArray(fieldInfo[1])\n      field.required = toBool(fieldInfo[2])\n      break\n    }\n    case 'CHECKBOX_GRID':\n    case 'RADIO_GRID': {\n      field.id = toString(rawField[0])\n      field.columns = flattenArray(rawField[4][0][1])\n      field.lines = parseLines(rawField[4])\n      field.required = toBool(rawField[4][0][2])\n      break\n    }\n    case 'DATE': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      field.required = toBool(rawField[4][0][2])\n      break\n    }\n  }\n\n  return field\n}\n\nconst parseFields = (\n  rawFields: Array<any>\n): { fields: Array<Field>; fieldsOrder: FieldsOrder } => {\n  const fieldsOrder = {}\n\n  const fields = rawFields.map((rawField: Array<any>, i: number) => {\n    const field = parseField(rawField)\n    fieldsOrder[`${field.id}`] = i\n    return field\n  })\n\n  return { fields, fieldsOrder }\n}\n\nconst parseFormData = ({ formData, fbzx }: FormData): GoogleForm => {\n  const googleForm = {} as GoogleForm\n\n  googleForm.fvv = 1\n  googleForm.pageHistory = 0\n  googleForm.fbzx = fbzx\n  googleForm.action = formData[14]\n  googleForm.title = formData[1][8]\n  googleForm.description = formData[1][0]\n\n  const { fields, fieldsOrder } = parseFields(formData[1][1])\n  googleForm.fields = fields\n  googleForm.fieldsOrder = fieldsOrder\n\n  return googleForm\n}\n\nexport const googleFormsToJson = async (formUrl: string) => {\n  assertValidUrl(formUrl)\n\n  let html\n  try {\n    html = await getFormHtml(formUrl)\n  } catch (err) {\n    throw new Error(`Failed to fetch form. ${err}`)\n  }\n\n  const formData = extractFormData(html)\n  return parseFormData(formData)\n}\n"],"names":["context","id","type","Error","field","getField","GoogleFormContext","React","useGoogleFormContext","GoogleFormProvider","children","other","Provider","value","OTHER_OPTION","OTHER_OPTION_RESPONSE","buildCustomFieldId","getFieldFromContext","useState","isCustomOptionSelected","setIsCustomOptionSelected","customInputRequired","setCustomInputRequired","register","options","required","currentValue","watch","useEffect","length","includes","nonCustomOptions","filter","o","custom","buildId","slugify","buildOptionRegister","label","registerOption","result","map","customOption","find","customOptionId","registerCustomInput","error","formState","errors","GOOGLE_FORMS_URL","formatQuestionName","replace","submitToGoogleForms","form","formData","urlParams","URLSearchParams","Object","keys","forEach","key","constructor","Array","answer","append","fetch","action","toString","method","mode","headers","fetchedResult","wasSuccessful","ok","status","resolveField","fieldIndex","fieldsOrder","undefined","fields","useGoogleForm","methods","useForm","useRadioInput","useCustomOptionField","useCheckboxInput","fieldType","useShortAnswerInput","useTextInput","useLongAnswerInput","setErrors","lineId","newErrors","lines","reduce","acc","l","fieldError","renderGrid","render","registerLine","renderColumns","columns","c","registerColumn","useCheckboxGridInput","useGridInput","useRadioGridInput","useDropdownInput","useLinearInput","toBool","n","assertValidUrl","formUrl","googleFormsHosts","url","URL","host","join","pathname","endsWith","getFormHtml","response","text","extractFormData","html","$","cheerio","load","fbzx","attr","scriptStringIdentifier","scriptHtml","_","el","first","slice","formDataRaw","JSON","parse","parseGridMultiSelect","rawField","firstLine","canSelectMultiple","parseFieldType","fieldId","fieldTypes","parseOptions","rawOption","parseCustomizableOptions","flattenArray","array","item","parseLines","rawLine","line","parseField","description","fieldInfo","labelFirst","labelLast","legend","parseFields","rawFields","i","parseFormData","googleForm","fvv","pageHistory","title","googleFormsToJson","err"],"mappings":"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"}