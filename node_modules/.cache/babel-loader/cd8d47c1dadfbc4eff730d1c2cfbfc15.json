{"ast":null,"code":"import { parse, SelectorType, isTraversal } from \"css-what\";\nimport { _compileToken as compileToken, prepareContext } from \"css-select\";\nimport * as DomUtils from \"domutils\";\nimport * as boolbase from \"boolbase\";\nimport { getDocumentRoot, groupSelectors } from \"./helpers.js\";\nimport { isFilter, getLimit } from \"./positionals.js\"; // Re-export pseudo extension points\n\nexport { filters, pseudos, aliases } from \"css-select\";\nconst UNIVERSAL_SELECTOR = {\n  type: SelectorType.Universal,\n  namespace: null\n};\nconst SCOPE_PSEUDO = {\n  type: SelectorType.Pseudo,\n  name: \"scope\",\n  data: null\n};\nexport function is(element, selector, options = {}) {\n  return some([element], selector, options);\n}\nexport function some(elements, selector, options = {}) {\n  if (typeof selector === \"function\") return elements.some(selector);\n  const [plain, filtered] = groupSelectors(parse(selector));\n  return plain.length > 0 && elements.some(compileToken(plain, options)) || filtered.some(sel => filterBySelector(sel, elements, options).length > 0);\n}\n\nfunction filterByPosition(filter, elems, data, options) {\n  const num = typeof data === \"string\" ? parseInt(data, 10) : NaN;\n\n  switch (filter) {\n    case \"first\":\n    case \"lt\":\n      // Already done in `getLimit`\n      return elems;\n\n    case \"last\":\n      return elems.length > 0 ? [elems[elems.length - 1]] : elems;\n\n    case \"nth\":\n    case \"eq\":\n      return isFinite(num) && Math.abs(num) < elems.length ? [num < 0 ? elems[elems.length + num] : elems[num]] : [];\n\n    case \"gt\":\n      return isFinite(num) ? elems.slice(num + 1) : [];\n\n    case \"even\":\n      return elems.filter((_, i) => i % 2 === 0);\n\n    case \"odd\":\n      return elems.filter((_, i) => i % 2 === 1);\n\n    case \"not\":\n      {\n        const filtered = new Set(filterParsed(data, elems, options));\n        return elems.filter(e => !filtered.has(e));\n      }\n  }\n}\n\nexport function filter(selector, elements, options = {}) {\n  return filterParsed(parse(selector), elements, options);\n}\n/**\n * Filter a set of elements by a selector.\n *\n * Will return elements in the original order.\n *\n * @param selector Selector to filter by.\n * @param elements Elements to filter.\n * @param options Options for selector.\n */\n\nfunction filterParsed(selector, elements, options) {\n  if (elements.length === 0) return [];\n  const [plainSelectors, filteredSelectors] = groupSelectors(selector);\n  let found;\n\n  if (plainSelectors.length) {\n    const filtered = filterElements(elements, plainSelectors, options); // If there are no filters, just return\n\n    if (filteredSelectors.length === 0) {\n      return filtered;\n    } // Otherwise, we have to do some filtering\n\n\n    if (filtered.length) {\n      found = new Set(filtered);\n    }\n  }\n\n  for (let i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {\n    const filteredSelector = filteredSelectors[i];\n    const missing = found ? elements.filter(e => DomUtils.isTag(e) && !found.has(e)) : elements;\n    if (missing.length === 0) break;\n    const filtered = filterBySelector(filteredSelector, elements, options);\n\n    if (filtered.length) {\n      if (!found) {\n        /*\n         * If we haven't found anything before the last selector,\n         * just return what we found now.\n         */\n        if (i === filteredSelectors.length - 1) {\n          return filtered;\n        }\n\n        found = new Set(filtered);\n      } else {\n        filtered.forEach(el => found.add(el));\n      }\n    }\n  }\n\n  return typeof found !== \"undefined\" ? found.size === elements.length ? elements : // Filter elements to preserve order\n  elements.filter(el => found.has(el)) : [];\n}\n\nfunction filterBySelector(selector, elements, options) {\n  var _a;\n\n  if (selector.some(isTraversal)) {\n    /*\n     * Get root node, run selector with the scope\n     * set to all of our nodes.\n     */\n    const root = (_a = options.root) !== null && _a !== void 0 ? _a : getDocumentRoot(elements[0]);\n    const opts = { ...options,\n      context: elements,\n      relativeSelector: false\n    };\n    selector.push(SCOPE_PSEUDO);\n    return findFilterElements(root, selector, opts, true, elements.length);\n  } // Performance optimization: If we don't have to traverse, just filter set.\n\n\n  return findFilterElements(elements, selector, options, false, elements.length);\n}\n\nexport function select(selector, root, options = {}, limit = Infinity) {\n  if (typeof selector === \"function\") {\n    return find(root, selector);\n  }\n\n  const [plain, filtered] = groupSelectors(parse(selector));\n  const results = filtered.map(sel => findFilterElements(root, sel, options, true, limit)); // Plain selectors can be queried in a single go\n\n  if (plain.length) {\n    results.push(findElements(root, plain, options, limit));\n  }\n\n  if (results.length === 0) {\n    return [];\n  } // If there was only a single selector, just return the result\n\n\n  if (results.length === 1) {\n    return results[0];\n  } // Sort results, filtering for duplicates\n\n\n  return DomUtils.uniqueSort(results.reduce((a, b) => [...a, ...b]));\n}\n/**\n *\n * @param root Element(s) to search from.\n * @param selector Selector to look for.\n * @param options Options for querying.\n * @param queryForSelector Query multiple levels deep for the initial selector, even if it doesn't contain a traversal.\n */\n\nfunction findFilterElements(root, selector, options, queryForSelector, totalLimit) {\n  const filterIndex = selector.findIndex(isFilter);\n  const sub = selector.slice(0, filterIndex);\n  const filter = selector[filterIndex]; // If we are at the end of the selector, we can limit the number of elements to retrieve.\n\n  const partLimit = selector.length - 1 === filterIndex ? totalLimit : Infinity;\n  /*\n   * Set the number of elements to retrieve.\n   * Eg. for :first, we only have to get a single element.\n   */\n\n  const limit = getLimit(filter.name, filter.data, partLimit);\n  if (limit === 0) return [];\n  /*\n   * Skip `findElements` call if our selector starts with a positional\n   * pseudo.\n   */\n\n  const elemsNoLimit = sub.length === 0 && !Array.isArray(root) ? DomUtils.getChildren(root).filter(DomUtils.isTag) : sub.length === 0 ? (Array.isArray(root) ? root : [root]).filter(DomUtils.isTag) : queryForSelector || sub.some(isTraversal) ? findElements(root, [sub], options, limit) : filterElements(root, [sub], options);\n  const elems = elemsNoLimit.slice(0, limit);\n  let result = filterByPosition(filter.name, elems, filter.data, options);\n\n  if (result.length === 0 || selector.length === filterIndex + 1) {\n    return result;\n  }\n\n  const remainingSelector = selector.slice(filterIndex + 1);\n  const remainingHasTraversal = remainingSelector.some(isTraversal);\n\n  if (remainingHasTraversal) {\n    if (isTraversal(remainingSelector[0])) {\n      const {\n        type\n      } = remainingSelector[0];\n\n      if (type === SelectorType.Sibling || type === SelectorType.Adjacent) {\n        // If we have a sibling traversal, we need to also look at the siblings.\n        result = prepareContext(result, DomUtils, true);\n      } // Avoid a traversal-first selector error.\n\n\n      remainingSelector.unshift(UNIVERSAL_SELECTOR);\n    }\n\n    options = { ...options,\n      // Avoid absolutizing the selector\n      relativeSelector: false,\n\n      /*\n       * Add a custom root func, to make sure traversals don't match elements\n       * that aren't a part of the considered tree.\n       */\n      rootFunc: el => result.includes(el)\n    };\n  } else if (options.rootFunc && options.rootFunc !== boolbase.trueFunc) {\n    options = { ...options,\n      rootFunc: boolbase.trueFunc\n    };\n  }\n  /*\n   * If we have another filter, recursively call `findFilterElements`,\n   * with the `recursive` flag disabled. We only have to look for more\n   * elements when we see a traversal.\n   *\n   * Otherwise,\n   */\n\n\n  return remainingSelector.some(isFilter) ? findFilterElements(result, remainingSelector, options, false, totalLimit) : remainingHasTraversal ? // Query existing elements to resolve traversal.\n  findElements(result, [remainingSelector], options, totalLimit) : // If we don't have any more traversals, simply filter elements.\n  filterElements(result, [remainingSelector], options);\n}\n\nfunction findElements(root, sel, options, limit) {\n  const query = compileToken(sel, options, root);\n  return find(root, query, limit);\n}\n\nfunction find(root, query, limit = Infinity) {\n  const elems = prepareContext(root, DomUtils, query.shouldTestNextSiblings);\n  return DomUtils.find(node => DomUtils.isTag(node) && query(node), elems, true, limit);\n}\n\nfunction filterElements(elements, sel, options) {\n  const els = (Array.isArray(elements) ? elements : [elements]).filter(DomUtils.isTag);\n  if (els.length === 0) return els;\n  const query = compileToken(sel, options);\n  return query === boolbase.trueFunc ? els : els.filter(query);\n}","map":{"version":3,"sources":["index.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/cheeriojs/cheerio-select/ef063a6ca4c3f0d02d2fc3505e750b6fb81c448d/src/","sourcesContent":["import { parse, SelectorType, isTraversal } from \"css-what\";\nimport { _compileToken as compileToken, prepareContext, } from \"css-select\";\nimport * as DomUtils from \"domutils\";\nimport * as boolbase from \"boolbase\";\nimport { getDocumentRoot, groupSelectors } from \"./helpers.js\";\nimport { isFilter, getLimit, } from \"./positionals.js\";\n// Re-export pseudo extension points\nexport { filters, pseudos, aliases } from \"css-select\";\nconst UNIVERSAL_SELECTOR = {\n    type: SelectorType.Universal,\n    namespace: null,\n};\nconst SCOPE_PSEUDO = {\n    type: SelectorType.Pseudo,\n    name: \"scope\",\n    data: null,\n};\nexport function is(element, selector, options = {}) {\n    return some([element], selector, options);\n}\nexport function some(elements, selector, options = {}) {\n    if (typeof selector === \"function\")\n        return elements.some(selector);\n    const [plain, filtered] = groupSelectors(parse(selector));\n    return ((plain.length > 0 && elements.some(compileToken(plain, options))) ||\n        filtered.some((sel) => filterBySelector(sel, elements, options).length > 0));\n}\nfunction filterByPosition(filter, elems, data, options) {\n    const num = typeof data === \"string\" ? parseInt(data, 10) : NaN;\n    switch (filter) {\n        case \"first\":\n        case \"lt\":\n            // Already done in `getLimit`\n            return elems;\n        case \"last\":\n            return elems.length > 0 ? [elems[elems.length - 1]] : elems;\n        case \"nth\":\n        case \"eq\":\n            return isFinite(num) && Math.abs(num) < elems.length\n                ? [num < 0 ? elems[elems.length + num] : elems[num]]\n                : [];\n        case \"gt\":\n            return isFinite(num) ? elems.slice(num + 1) : [];\n        case \"even\":\n            return elems.filter((_, i) => i % 2 === 0);\n        case \"odd\":\n            return elems.filter((_, i) => i % 2 === 1);\n        case \"not\": {\n            const filtered = new Set(filterParsed(data, elems, options));\n            return elems.filter((e) => !filtered.has(e));\n        }\n    }\n}\nexport function filter(selector, elements, options = {}) {\n    return filterParsed(parse(selector), elements, options);\n}\n/**\n * Filter a set of elements by a selector.\n *\n * Will return elements in the original order.\n *\n * @param selector Selector to filter by.\n * @param elements Elements to filter.\n * @param options Options for selector.\n */\nfunction filterParsed(selector, elements, options) {\n    if (elements.length === 0)\n        return [];\n    const [plainSelectors, filteredSelectors] = groupSelectors(selector);\n    let found;\n    if (plainSelectors.length) {\n        const filtered = filterElements(elements, plainSelectors, options);\n        // If there are no filters, just return\n        if (filteredSelectors.length === 0) {\n            return filtered;\n        }\n        // Otherwise, we have to do some filtering\n        if (filtered.length) {\n            found = new Set(filtered);\n        }\n    }\n    for (let i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {\n        const filteredSelector = filteredSelectors[i];\n        const missing = found\n            ? elements.filter((e) => DomUtils.isTag(e) && !found.has(e))\n            : elements;\n        if (missing.length === 0)\n            break;\n        const filtered = filterBySelector(filteredSelector, elements, options);\n        if (filtered.length) {\n            if (!found) {\n                /*\n                 * If we haven't found anything before the last selector,\n                 * just return what we found now.\n                 */\n                if (i === filteredSelectors.length - 1) {\n                    return filtered;\n                }\n                found = new Set(filtered);\n            }\n            else {\n                filtered.forEach((el) => found.add(el));\n            }\n        }\n    }\n    return typeof found !== \"undefined\"\n        ? (found.size === elements.length\n            ? elements\n            : // Filter elements to preserve order\n                elements.filter((el) => found.has(el)))\n        : [];\n}\nfunction filterBySelector(selector, elements, options) {\n    var _a;\n    if (selector.some(isTraversal)) {\n        /*\n         * Get root node, run selector with the scope\n         * set to all of our nodes.\n         */\n        const root = (_a = options.root) !== null && _a !== void 0 ? _a : getDocumentRoot(elements[0]);\n        const opts = { ...options, context: elements, relativeSelector: false };\n        selector.push(SCOPE_PSEUDO);\n        return findFilterElements(root, selector, opts, true, elements.length);\n    }\n    // Performance optimization: If we don't have to traverse, just filter set.\n    return findFilterElements(elements, selector, options, false, elements.length);\n}\nexport function select(selector, root, options = {}, limit = Infinity) {\n    if (typeof selector === \"function\") {\n        return find(root, selector);\n    }\n    const [plain, filtered] = groupSelectors(parse(selector));\n    const results = filtered.map((sel) => findFilterElements(root, sel, options, true, limit));\n    // Plain selectors can be queried in a single go\n    if (plain.length) {\n        results.push(findElements(root, plain, options, limit));\n    }\n    if (results.length === 0) {\n        return [];\n    }\n    // If there was only a single selector, just return the result\n    if (results.length === 1) {\n        return results[0];\n    }\n    // Sort results, filtering for duplicates\n    return DomUtils.uniqueSort(results.reduce((a, b) => [...a, ...b]));\n}\n/**\n *\n * @param root Element(s) to search from.\n * @param selector Selector to look for.\n * @param options Options for querying.\n * @param queryForSelector Query multiple levels deep for the initial selector, even if it doesn't contain a traversal.\n */\nfunction findFilterElements(root, selector, options, queryForSelector, totalLimit) {\n    const filterIndex = selector.findIndex(isFilter);\n    const sub = selector.slice(0, filterIndex);\n    const filter = selector[filterIndex];\n    // If we are at the end of the selector, we can limit the number of elements to retrieve.\n    const partLimit = selector.length - 1 === filterIndex ? totalLimit : Infinity;\n    /*\n     * Set the number of elements to retrieve.\n     * Eg. for :first, we only have to get a single element.\n     */\n    const limit = getLimit(filter.name, filter.data, partLimit);\n    if (limit === 0)\n        return [];\n    /*\n     * Skip `findElements` call if our selector starts with a positional\n     * pseudo.\n     */\n    const elemsNoLimit = sub.length === 0 && !Array.isArray(root)\n        ? DomUtils.getChildren(root).filter(DomUtils.isTag)\n        : sub.length === 0\n            ? (Array.isArray(root) ? root : [root]).filter(DomUtils.isTag)\n            : queryForSelector || sub.some(isTraversal)\n                ? findElements(root, [sub], options, limit)\n                : filterElements(root, [sub], options);\n    const elems = elemsNoLimit.slice(0, limit);\n    let result = filterByPosition(filter.name, elems, filter.data, options);\n    if (result.length === 0 || selector.length === filterIndex + 1) {\n        return result;\n    }\n    const remainingSelector = selector.slice(filterIndex + 1);\n    const remainingHasTraversal = remainingSelector.some(isTraversal);\n    if (remainingHasTraversal) {\n        if (isTraversal(remainingSelector[0])) {\n            const { type } = remainingSelector[0];\n            if (type === SelectorType.Sibling ||\n                type === SelectorType.Adjacent) {\n                // If we have a sibling traversal, we need to also look at the siblings.\n                result = prepareContext(result, DomUtils, true);\n            }\n            // Avoid a traversal-first selector error.\n            remainingSelector.unshift(UNIVERSAL_SELECTOR);\n        }\n        options = {\n            ...options,\n            // Avoid absolutizing the selector\n            relativeSelector: false,\n            /*\n             * Add a custom root func, to make sure traversals don't match elements\n             * that aren't a part of the considered tree.\n             */\n            rootFunc: (el) => result.includes(el),\n        };\n    }\n    else if (options.rootFunc && options.rootFunc !== boolbase.trueFunc) {\n        options = { ...options, rootFunc: boolbase.trueFunc };\n    }\n    /*\n     * If we have another filter, recursively call `findFilterElements`,\n     * with the `recursive` flag disabled. We only have to look for more\n     * elements when we see a traversal.\n     *\n     * Otherwise,\n     */\n    return remainingSelector.some(isFilter)\n        ? findFilterElements(result, remainingSelector, options, false, totalLimit)\n        : remainingHasTraversal\n            ? // Query existing elements to resolve traversal.\n                findElements(result, [remainingSelector], options, totalLimit)\n            : // If we don't have any more traversals, simply filter elements.\n                filterElements(result, [remainingSelector], options);\n}\nfunction findElements(root, sel, options, limit) {\n    const query = compileToken(sel, options, root);\n    return find(root, query, limit);\n}\nfunction find(root, query, limit = Infinity) {\n    const elems = prepareContext(root, DomUtils, query.shouldTestNextSiblings);\n    return DomUtils.find((node) => DomUtils.isTag(node) && query(node), elems, true, limit);\n}\nfunction filterElements(elements, sel, options) {\n    const els = (Array.isArray(elements) ? elements : [elements]).filter(DomUtils.isTag);\n    if (els.length === 0)\n        return els;\n    const query = compileToken(sel, options);\n    return query === boolbase.trueFunc ? els : els.filter(query);\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}