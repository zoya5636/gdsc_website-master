{"ast":null,"code":"/**\n * Methods for getting and modifying attributes.\n *\n * @module cheerio/attributes\n */\nimport { text } from '../static.js';\nimport { isTag, domEach, camelCase, cssCase } from '../utils.js';\nimport { innerText, textContent } from 'domutils';\nconst hasOwn = Object.prototype.hasOwnProperty;\nconst rspace = /\\s+/;\nconst dataAttrPrefix = 'data-';\n/*\n * Lookup table for coercing string data-* attributes to their corresponding\n * JavaScript primitives\n */\n\nconst primitives = {\n  null: null,\n  true: true,\n  false: false\n}; // Attributes that are booleans\n\nconst rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i; // Matches strings that look like JSON objects or arrays\n\nconst rbrace = /^{[^]*}$|^\\[[^]*]$/;\n\nfunction getAttr(elem, name, xmlMode) {\n  var _a;\n\n  if (!elem || !isTag(elem)) return undefined;\n  (_a = elem.attribs) !== null && _a !== void 0 ? _a : elem.attribs = {}; // Return the entire attribs object if no attribute specified\n\n  if (!name) {\n    return elem.attribs;\n  }\n\n  if (hasOwn.call(elem.attribs, name)) {\n    // Get the (decoded) attribute\n    return !xmlMode && rboolean.test(name) ? name : elem.attribs[name];\n  } // Mimic the DOM and return text content as value for `option's`\n\n\n  if (elem.name === 'option' && name === 'value') {\n    return text(elem.children);\n  } // Mimic DOM with default value for radios/checkboxes\n\n\n  if (elem.name === 'input' && (elem.attribs['type'] === 'radio' || elem.attribs['type'] === 'checkbox') && name === 'value') {\n    return 'on';\n  }\n\n  return undefined;\n}\n/**\n * Sets the value of an attribute. The attribute will be deleted if the value is `null`.\n *\n * @private\n * @param el - The element to set the attribute on.\n * @param name - The attribute's name.\n * @param value - The attribute's value.\n */\n\n\nfunction setAttr(el, name, value) {\n  if (value === null) {\n    removeAttribute(el, name);\n  } else {\n    el.attribs[name] = `${value}`;\n  }\n}\n\nexport function attr(name, value) {\n  // Set the value (with attr map support)\n  if (typeof name === 'object' || value !== undefined) {\n    if (typeof value === 'function') {\n      if (typeof name !== 'string') {\n        {\n          throw new Error('Bad combination of arguments.');\n        }\n      }\n\n      return domEach(this, (el, i) => {\n        if (isTag(el)) setAttr(el, name, value.call(el, i, el.attribs[name]));\n      });\n    }\n\n    return domEach(this, el => {\n      if (!isTag(el)) return;\n\n      if (typeof name === 'object') {\n        Object.keys(name).forEach(objName => {\n          const objValue = name[objName];\n          setAttr(el, objName, objValue);\n        });\n      } else {\n        setAttr(el, name, value);\n      }\n    });\n  }\n\n  return arguments.length > 1 ? this : getAttr(this[0], name, this.options.xmlMode);\n}\n/**\n * Gets a node's prop.\n *\n * @private\n * @category Attributes\n * @param el - Element to get the prop of.\n * @param name - Name of the prop.\n * @returns The prop's value.\n */\n\nfunction getProp(el, name, xmlMode) {\n  return name in el ? // @ts-expect-error TS doesn't like us accessing the value directly here.\n  el[name] : !xmlMode && rboolean.test(name) ? getAttr(el, name, false) !== undefined : getAttr(el, name, xmlMode);\n}\n/**\n * Sets the value of a prop.\n *\n * @private\n * @param el - The element to set the prop on.\n * @param name - The prop's name.\n * @param value - The prop's value.\n */\n\n\nfunction setProp(el, name, value, xmlMode) {\n  if (name in el) {\n    // @ts-expect-error Overriding value\n    el[name] = value;\n  } else {\n    setAttr(el, name, !xmlMode && rboolean.test(name) ? value ? '' : null : `${value}`);\n  }\n}\n\nexport function prop(name, value) {\n  var _a;\n\n  if (typeof name === 'string' && value === undefined) {\n    const el = this[0];\n    if (!el || !isTag(el)) return undefined;\n\n    switch (name) {\n      case 'style':\n        {\n          const property = this.css();\n          const keys = Object.keys(property);\n          keys.forEach((p, i) => {\n            property[i] = p;\n          });\n          property.length = keys.length;\n          return property;\n        }\n\n      case 'tagName':\n      case 'nodeName':\n        {\n          return el.name.toUpperCase();\n        }\n\n      case 'href':\n      case 'src':\n        {\n          const prop = (_a = el.attribs) === null || _a === void 0 ? void 0 : _a[name];\n          /* eslint-disable node/no-unsupported-features/node-builtins */\n\n          if (typeof URL !== 'undefined' && (name === 'href' && (el.tagName === 'a' || el.name === 'link') || name === 'src' && (el.tagName === 'img' || el.tagName === 'iframe' || el.tagName === 'audio' || el.tagName === 'video' || el.tagName === 'source')) && prop !== undefined && this.options.baseURI) {\n            return new URL(prop, this.options.baseURI).href;\n          }\n          /* eslint-enable node/no-unsupported-features/node-builtins */\n\n\n          return prop;\n        }\n\n      case 'innerText':\n        {\n          return innerText(el);\n        }\n\n      case 'textContent':\n        {\n          return textContent(el);\n        }\n\n      case 'outerHTML':\n        return this.clone().wrap('<container />').parent().html();\n\n      case 'innerHTML':\n        return this.html();\n\n      default:\n        return getProp(el, name, this.options.xmlMode);\n    }\n  }\n\n  if (typeof name === 'object' || value !== undefined) {\n    if (typeof value === 'function') {\n      if (typeof name === 'object') {\n        throw new Error('Bad combination of arguments.');\n      }\n\n      return domEach(this, (el, i) => {\n        if (isTag(el)) {\n          setProp(el, name, value.call(el, i, getProp(el, name, this.options.xmlMode)), this.options.xmlMode);\n        }\n      });\n    }\n\n    return domEach(this, el => {\n      if (!isTag(el)) return;\n\n      if (typeof name === 'object') {\n        Object.keys(name).forEach(key => {\n          const val = name[key];\n          setProp(el, key, val, this.options.xmlMode);\n        });\n      } else {\n        setProp(el, name, value, this.options.xmlMode);\n      }\n    });\n  }\n\n  return undefined;\n}\n/**\n * Sets the value of a data attribute.\n *\n * @private\n * @param el - The element to set the data attribute on.\n * @param name - The data attribute's name.\n * @param value - The data attribute's value.\n */\n\nfunction setData(el, name, value) {\n  var _a;\n\n  const elem = el;\n  (_a = elem.data) !== null && _a !== void 0 ? _a : elem.data = {};\n  if (typeof name === 'object') Object.assign(elem.data, name);else if (typeof name === 'string' && value !== undefined) {\n    elem.data[name] = value;\n  }\n}\n/**\n * Read the specified attribute from the equivalent HTML5 `data-*` attribute,\n * and (if present) cache the value in the node's internal data store. If no\n * attribute name is specified, read _all_ HTML5 `data-*` attributes in this manner.\n *\n * @private\n * @category Attributes\n * @param el - Element to get the data attribute of.\n * @param name - Name of the data attribute.\n * @returns The data attribute's value, or a map with all of the data attributes.\n */\n\n\nfunction readData(el, name) {\n  let domNames;\n  let jsNames;\n  let value;\n\n  if (name == null) {\n    domNames = Object.keys(el.attribs).filter(attrName => attrName.startsWith(dataAttrPrefix));\n    jsNames = domNames.map(domName => camelCase(domName.slice(dataAttrPrefix.length)));\n  } else {\n    domNames = [dataAttrPrefix + cssCase(name)];\n    jsNames = [name];\n  }\n\n  for (let idx = 0; idx < domNames.length; ++idx) {\n    const domName = domNames[idx];\n    const jsName = jsNames[idx];\n\n    if (hasOwn.call(el.attribs, domName) && !hasOwn.call(el.data, jsName)) {\n      value = el.attribs[domName];\n\n      if (hasOwn.call(primitives, value)) {\n        value = primitives[value];\n      } else if (value === String(Number(value))) {\n        value = Number(value);\n      } else if (rbrace.test(value)) {\n        try {\n          value = JSON.parse(value);\n        } catch (e) {\n          /* Ignore */\n        }\n      }\n\n      el.data[jsName] = value;\n    }\n  }\n\n  return name == null ? el.data : value;\n}\n\nexport function data(name, value) {\n  var _a;\n\n  const elem = this[0];\n  if (!elem || !isTag(elem)) return;\n  const dataEl = elem;\n  (_a = dataEl.data) !== null && _a !== void 0 ? _a : dataEl.data = {}; // Return the entire data object if no data specified\n\n  if (!name) {\n    return readData(dataEl);\n  } // Set the value (with attr map support)\n\n\n  if (typeof name === 'object' || value !== undefined) {\n    domEach(this, el => {\n      if (isTag(el)) {\n        if (typeof name === 'object') setData(el, name);else setData(el, name, value);\n      }\n    });\n    return this;\n  }\n\n  if (hasOwn.call(dataEl.data, name)) {\n    return dataEl.data[name];\n  }\n\n  return readData(dataEl, name);\n}\nexport function val(value) {\n  const querying = arguments.length === 0;\n  const element = this[0];\n  if (!element || !isTag(element)) return querying ? undefined : this;\n\n  switch (element.name) {\n    case 'textarea':\n      return this.text(value);\n\n    case 'select':\n      {\n        const option = this.find('option:selected');\n\n        if (!querying) {\n          if (this.attr('multiple') == null && typeof value === 'object') {\n            return this;\n          }\n\n          this.find('option').removeAttr('selected');\n          const values = typeof value !== 'object' ? [value] : value;\n\n          for (let i = 0; i < values.length; i++) {\n            this.find(`option[value=\"${values[i]}\"]`).attr('selected', '');\n          }\n\n          return this;\n        }\n\n        return this.attr('multiple') ? option.toArray().map(el => text(el.children)) : option.attr('value');\n      }\n\n    case 'input':\n    case 'option':\n      return querying ? this.attr('value') : this.attr('value', value);\n  }\n\n  return undefined;\n}\n/**\n * Remove an attribute.\n *\n * @private\n * @param elem - Node to remove attribute from.\n * @param name - Name of the attribute to remove.\n */\n\nfunction removeAttribute(elem, name) {\n  if (!elem.attribs || !hasOwn.call(elem.attribs, name)) return;\n  delete elem.attribs[name];\n}\n/**\n * Splits a space-separated list of names to individual names.\n *\n * @category Attributes\n * @param names - Names to split.\n * @returns - Split names.\n */\n\n\nfunction splitNames(names) {\n  return names ? names.trim().split(rspace) : [];\n}\n/**\n * Method for removing attributes by `name`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').removeAttr('class').html();\n * //=> <li>Pear</li>\n *\n * $('.apple').attr('id', 'favorite');\n * $('.apple').removeAttr('id class').html();\n * //=> <li>Apple</li>\n * ```\n *\n * @param name - Name of the attribute.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/removeAttr/}\n */\n\n\nexport function removeAttr(name) {\n  const attrNames = splitNames(name);\n\n  for (let i = 0; i < attrNames.length; i++) {\n    domEach(this, elem => {\n      if (isTag(elem)) removeAttribute(elem, attrNames[i]);\n    });\n  }\n\n  return this;\n}\n/**\n * Check to see if _any_ of the matched elements have the given `className`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').hasClass('pear');\n * //=> true\n *\n * $('apple').hasClass('fruit');\n * //=> false\n *\n * $('li').hasClass('pear');\n * //=> true\n * ```\n *\n * @param className - Name of the class.\n * @returns Indicates if an element has the given `className`.\n * @see {@link https://api.jquery.com/hasClass/}\n */\n\nexport function hasClass(className) {\n  return this.toArray().some(elem => {\n    const clazz = isTag(elem) && elem.attribs['class'];\n    let idx = -1;\n\n    if (clazz && className.length) {\n      while ((idx = clazz.indexOf(className, idx + 1)) > -1) {\n        const end = idx + className.length;\n\n        if ((idx === 0 || rspace.test(clazz[idx - 1])) && (end === clazz.length || rspace.test(clazz[end]))) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  });\n}\n/**\n * Adds class(es) to all of the matched elements. Also accepts a `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').addClass('fruit').html();\n * //=> <li class=\"pear fruit\">Pear</li>\n *\n * $('.apple').addClass('fruit red').html();\n * //=> <li class=\"apple fruit red\">Apple</li>\n * ```\n *\n * @param value - Name of new class.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/addClass/}\n */\n\nexport function addClass(value) {\n  // Support functions\n  if (typeof value === 'function') {\n    return domEach(this, (el, i) => {\n      if (isTag(el)) {\n        const className = el.attribs['class'] || '';\n        addClass.call([el], value.call(el, i, className));\n      }\n    });\n  } // Return if no value or not a string or function\n\n\n  if (!value || typeof value !== 'string') return this;\n  const classNames = value.split(rspace);\n  const numElements = this.length;\n\n  for (let i = 0; i < numElements; i++) {\n    const el = this[i]; // If selected element isn't a tag, move on\n\n    if (!isTag(el)) continue; // If we don't already have classes — always set xmlMode to false here, as it doesn't matter for classes\n\n    const className = getAttr(el, 'class', false);\n\n    if (!className) {\n      setAttr(el, 'class', classNames.join(' ').trim());\n    } else {\n      let setClass = ` ${className} `; // Check if class already exists\n\n      for (let j = 0; j < classNames.length; j++) {\n        const appendClass = `${classNames[j]} `;\n        if (!setClass.includes(` ${appendClass}`)) setClass += appendClass;\n      }\n\n      setAttr(el, 'class', setClass.trim());\n    }\n  }\n\n  return this;\n}\n/**\n * Removes one or more space-separated classes from the selected elements. If no\n * `className` is defined, all classes will be removed. Also accepts a `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').removeClass('pear').html();\n * //=> <li class=\"\">Pear</li>\n *\n * $('.apple').addClass('red').removeClass().html();\n * //=> <li class=\"\">Apple</li>\n * ```\n *\n * @param name - Name of the class. If not specified, removes all elements.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/removeClass/}\n */\n\nexport function removeClass(name) {\n  // Handle if value is a function\n  if (typeof name === 'function') {\n    return domEach(this, (el, i) => {\n      if (isTag(el)) {\n        removeClass.call([el], name.call(el, i, el.attribs['class'] || ''));\n      }\n    });\n  }\n\n  const classes = splitNames(name);\n  const numClasses = classes.length;\n  const removeAll = arguments.length === 0;\n  return domEach(this, el => {\n    if (!isTag(el)) return;\n\n    if (removeAll) {\n      // Short circuit the remove all case as this is the nice one\n      el.attribs['class'] = '';\n    } else {\n      const elClasses = splitNames(el.attribs['class']);\n      let changed = false;\n\n      for (let j = 0; j < numClasses; j++) {\n        const index = elClasses.indexOf(classes[j]);\n\n        if (index >= 0) {\n          elClasses.splice(index, 1);\n          changed = true;\n          /*\n           * We have to do another pass to ensure that there are not duplicate\n           * classes listed\n           */\n\n          j--;\n        }\n      }\n\n      if (changed) {\n        el.attribs['class'] = elClasses.join(' ');\n      }\n    }\n  });\n}\n/**\n * Add or remove class(es) from the matched elements, depending on either the\n * class's presence or the value of the switch argument. Also accepts a `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.apple.green').toggleClass('fruit green red').html();\n * //=> <li class=\"apple fruit red\">Apple</li>\n *\n * $('.apple.green').toggleClass('fruit green red', true).html();\n * //=> <li class=\"apple green fruit red\">Apple</li>\n * ```\n *\n * @param value - Name of the class. Can also be a function.\n * @param stateVal - If specified the state of the class.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/toggleClass/}\n */\n\nexport function toggleClass(value, stateVal) {\n  // Support functions\n  if (typeof value === 'function') {\n    return domEach(this, (el, i) => {\n      if (isTag(el)) {\n        toggleClass.call([el], value.call(el, i, el.attribs['class'] || '', stateVal), stateVal);\n      }\n    });\n  } // Return if no value or not a string or function\n\n\n  if (!value || typeof value !== 'string') return this;\n  const classNames = value.split(rspace);\n  const numClasses = classNames.length;\n  const state = typeof stateVal === 'boolean' ? stateVal ? 1 : -1 : 0;\n  const numElements = this.length;\n\n  for (let i = 0; i < numElements; i++) {\n    const el = this[i]; // If selected element isn't a tag, move on\n\n    if (!isTag(el)) continue;\n    const elementClasses = splitNames(el.attribs['class']); // Check if class already exists\n\n    for (let j = 0; j < numClasses; j++) {\n      // Check if the class name is currently defined\n      const index = elementClasses.indexOf(classNames[j]); // Add if stateValue === true or we are toggling and there is no value\n\n      if (state >= 0 && index < 0) {\n        elementClasses.push(classNames[j]);\n      } else if (state <= 0 && index >= 0) {\n        // Otherwise remove but only if the item exists\n        elementClasses.splice(index, 1);\n      }\n    }\n\n    el.attribs['class'] = elementClasses.join(' ');\n  }\n\n  return this;\n}","map":{"version":3,"sources":["api/attributes.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/cheeriojs/cheerio/d1cbc66d53392ce8bf6cd0068f675836372d2bf3/src/","sourcesContent":["/**\n * Methods for getting and modifying attributes.\n *\n * @module cheerio/attributes\n */\nimport { text } from '../static.js';\nimport { isTag, domEach, camelCase, cssCase } from '../utils.js';\nimport { innerText, textContent } from 'domutils';\nconst hasOwn = Object.prototype.hasOwnProperty;\nconst rspace = /\\s+/;\nconst dataAttrPrefix = 'data-';\n/*\n * Lookup table for coercing string data-* attributes to their corresponding\n * JavaScript primitives\n */\nconst primitives = {\n    null: null,\n    true: true,\n    false: false,\n};\n// Attributes that are booleans\nconst rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;\n// Matches strings that look like JSON objects or arrays\nconst rbrace = /^{[^]*}$|^\\[[^]*]$/;\nfunction getAttr(elem, name, xmlMode) {\n    var _a;\n    if (!elem || !isTag(elem))\n        return undefined;\n    (_a = elem.attribs) !== null && _a !== void 0 ? _a : (elem.attribs = {});\n    // Return the entire attribs object if no attribute specified\n    if (!name) {\n        return elem.attribs;\n    }\n    if (hasOwn.call(elem.attribs, name)) {\n        // Get the (decoded) attribute\n        return !xmlMode && rboolean.test(name) ? name : elem.attribs[name];\n    }\n    // Mimic the DOM and return text content as value for `option's`\n    if (elem.name === 'option' && name === 'value') {\n        return text(elem.children);\n    }\n    // Mimic DOM with default value for radios/checkboxes\n    if (elem.name === 'input' &&\n        (elem.attribs['type'] === 'radio' || elem.attribs['type'] === 'checkbox') &&\n        name === 'value') {\n        return 'on';\n    }\n    return undefined;\n}\n/**\n * Sets the value of an attribute. The attribute will be deleted if the value is `null`.\n *\n * @private\n * @param el - The element to set the attribute on.\n * @param name - The attribute's name.\n * @param value - The attribute's value.\n */\nfunction setAttr(el, name, value) {\n    if (value === null) {\n        removeAttribute(el, name);\n    }\n    else {\n        el.attribs[name] = `${value}`;\n    }\n}\nexport function attr(name, value) {\n    // Set the value (with attr map support)\n    if (typeof name === 'object' || value !== undefined) {\n        if (typeof value === 'function') {\n            if (typeof name !== 'string') {\n                {\n                    throw new Error('Bad combination of arguments.');\n                }\n            }\n            return domEach(this, (el, i) => {\n                if (isTag(el))\n                    setAttr(el, name, value.call(el, i, el.attribs[name]));\n            });\n        }\n        return domEach(this, (el) => {\n            if (!isTag(el))\n                return;\n            if (typeof name === 'object') {\n                Object.keys(name).forEach((objName) => {\n                    const objValue = name[objName];\n                    setAttr(el, objName, objValue);\n                });\n            }\n            else {\n                setAttr(el, name, value);\n            }\n        });\n    }\n    return arguments.length > 1\n        ? this\n        : getAttr(this[0], name, this.options.xmlMode);\n}\n/**\n * Gets a node's prop.\n *\n * @private\n * @category Attributes\n * @param el - Element to get the prop of.\n * @param name - Name of the prop.\n * @returns The prop's value.\n */\nfunction getProp(el, name, xmlMode) {\n    return name in el\n        ? // @ts-expect-error TS doesn't like us accessing the value directly here.\n            el[name]\n        : !xmlMode && rboolean.test(name)\n            ? getAttr(el, name, false) !== undefined\n            : getAttr(el, name, xmlMode);\n}\n/**\n * Sets the value of a prop.\n *\n * @private\n * @param el - The element to set the prop on.\n * @param name - The prop's name.\n * @param value - The prop's value.\n */\nfunction setProp(el, name, value, xmlMode) {\n    if (name in el) {\n        // @ts-expect-error Overriding value\n        el[name] = value;\n    }\n    else {\n        setAttr(el, name, !xmlMode && rboolean.test(name) ? (value ? '' : null) : `${value}`);\n    }\n}\nexport function prop(name, value) {\n    var _a;\n    if (typeof name === 'string' && value === undefined) {\n        const el = this[0];\n        if (!el || !isTag(el))\n            return undefined;\n        switch (name) {\n            case 'style': {\n                const property = this.css();\n                const keys = Object.keys(property);\n                keys.forEach((p, i) => {\n                    property[i] = p;\n                });\n                property.length = keys.length;\n                return property;\n            }\n            case 'tagName':\n            case 'nodeName': {\n                return el.name.toUpperCase();\n            }\n            case 'href':\n            case 'src': {\n                const prop = (_a = el.attribs) === null || _a === void 0 ? void 0 : _a[name];\n                /* eslint-disable node/no-unsupported-features/node-builtins */\n                if (typeof URL !== 'undefined' &&\n                    ((name === 'href' && (el.tagName === 'a' || el.name === 'link')) ||\n                        (name === 'src' &&\n                            (el.tagName === 'img' ||\n                                el.tagName === 'iframe' ||\n                                el.tagName === 'audio' ||\n                                el.tagName === 'video' ||\n                                el.tagName === 'source'))) &&\n                    prop !== undefined &&\n                    this.options.baseURI) {\n                    return new URL(prop, this.options.baseURI).href;\n                }\n                /* eslint-enable node/no-unsupported-features/node-builtins */\n                return prop;\n            }\n            case 'innerText': {\n                return innerText(el);\n            }\n            case 'textContent': {\n                return textContent(el);\n            }\n            case 'outerHTML':\n                return this.clone().wrap('<container />').parent().html();\n            case 'innerHTML':\n                return this.html();\n            default:\n                return getProp(el, name, this.options.xmlMode);\n        }\n    }\n    if (typeof name === 'object' || value !== undefined) {\n        if (typeof value === 'function') {\n            if (typeof name === 'object') {\n                throw new Error('Bad combination of arguments.');\n            }\n            return domEach(this, (el, i) => {\n                if (isTag(el)) {\n                    setProp(el, name, value.call(el, i, getProp(el, name, this.options.xmlMode)), this.options.xmlMode);\n                }\n            });\n        }\n        return domEach(this, (el) => {\n            if (!isTag(el))\n                return;\n            if (typeof name === 'object') {\n                Object.keys(name).forEach((key) => {\n                    const val = name[key];\n                    setProp(el, key, val, this.options.xmlMode);\n                });\n            }\n            else {\n                setProp(el, name, value, this.options.xmlMode);\n            }\n        });\n    }\n    return undefined;\n}\n/**\n * Sets the value of a data attribute.\n *\n * @private\n * @param el - The element to set the data attribute on.\n * @param name - The data attribute's name.\n * @param value - The data attribute's value.\n */\nfunction setData(el, name, value) {\n    var _a;\n    const elem = el;\n    (_a = elem.data) !== null && _a !== void 0 ? _a : (elem.data = {});\n    if (typeof name === 'object')\n        Object.assign(elem.data, name);\n    else if (typeof name === 'string' && value !== undefined) {\n        elem.data[name] = value;\n    }\n}\n/**\n * Read the specified attribute from the equivalent HTML5 `data-*` attribute,\n * and (if present) cache the value in the node's internal data store. If no\n * attribute name is specified, read _all_ HTML5 `data-*` attributes in this manner.\n *\n * @private\n * @category Attributes\n * @param el - Element to get the data attribute of.\n * @param name - Name of the data attribute.\n * @returns The data attribute's value, or a map with all of the data attributes.\n */\nfunction readData(el, name) {\n    let domNames;\n    let jsNames;\n    let value;\n    if (name == null) {\n        domNames = Object.keys(el.attribs).filter((attrName) => attrName.startsWith(dataAttrPrefix));\n        jsNames = domNames.map((domName) => camelCase(domName.slice(dataAttrPrefix.length)));\n    }\n    else {\n        domNames = [dataAttrPrefix + cssCase(name)];\n        jsNames = [name];\n    }\n    for (let idx = 0; idx < domNames.length; ++idx) {\n        const domName = domNames[idx];\n        const jsName = jsNames[idx];\n        if (hasOwn.call(el.attribs, domName) &&\n            !hasOwn.call(el.data, jsName)) {\n            value = el.attribs[domName];\n            if (hasOwn.call(primitives, value)) {\n                value = primitives[value];\n            }\n            else if (value === String(Number(value))) {\n                value = Number(value);\n            }\n            else if (rbrace.test(value)) {\n                try {\n                    value = JSON.parse(value);\n                }\n                catch (e) {\n                    /* Ignore */\n                }\n            }\n            el.data[jsName] = value;\n        }\n    }\n    return name == null ? el.data : value;\n}\nexport function data(name, value) {\n    var _a;\n    const elem = this[0];\n    if (!elem || !isTag(elem))\n        return;\n    const dataEl = elem;\n    (_a = dataEl.data) !== null && _a !== void 0 ? _a : (dataEl.data = {});\n    // Return the entire data object if no data specified\n    if (!name) {\n        return readData(dataEl);\n    }\n    // Set the value (with attr map support)\n    if (typeof name === 'object' || value !== undefined) {\n        domEach(this, (el) => {\n            if (isTag(el)) {\n                if (typeof name === 'object')\n                    setData(el, name);\n                else\n                    setData(el, name, value);\n            }\n        });\n        return this;\n    }\n    if (hasOwn.call(dataEl.data, name)) {\n        return dataEl.data[name];\n    }\n    return readData(dataEl, name);\n}\nexport function val(value) {\n    const querying = arguments.length === 0;\n    const element = this[0];\n    if (!element || !isTag(element))\n        return querying ? undefined : this;\n    switch (element.name) {\n        case 'textarea':\n            return this.text(value);\n        case 'select': {\n            const option = this.find('option:selected');\n            if (!querying) {\n                if (this.attr('multiple') == null && typeof value === 'object') {\n                    return this;\n                }\n                this.find('option').removeAttr('selected');\n                const values = typeof value !== 'object' ? [value] : value;\n                for (let i = 0; i < values.length; i++) {\n                    this.find(`option[value=\"${values[i]}\"]`).attr('selected', '');\n                }\n                return this;\n            }\n            return this.attr('multiple')\n                ? option.toArray().map((el) => text(el.children))\n                : option.attr('value');\n        }\n        case 'input':\n        case 'option':\n            return querying\n                ? this.attr('value')\n                : this.attr('value', value);\n    }\n    return undefined;\n}\n/**\n * Remove an attribute.\n *\n * @private\n * @param elem - Node to remove attribute from.\n * @param name - Name of the attribute to remove.\n */\nfunction removeAttribute(elem, name) {\n    if (!elem.attribs || !hasOwn.call(elem.attribs, name))\n        return;\n    delete elem.attribs[name];\n}\n/**\n * Splits a space-separated list of names to individual names.\n *\n * @category Attributes\n * @param names - Names to split.\n * @returns - Split names.\n */\nfunction splitNames(names) {\n    return names ? names.trim().split(rspace) : [];\n}\n/**\n * Method for removing attributes by `name`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').removeAttr('class').html();\n * //=> <li>Pear</li>\n *\n * $('.apple').attr('id', 'favorite');\n * $('.apple').removeAttr('id class').html();\n * //=> <li>Apple</li>\n * ```\n *\n * @param name - Name of the attribute.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/removeAttr/}\n */\nexport function removeAttr(name) {\n    const attrNames = splitNames(name);\n    for (let i = 0; i < attrNames.length; i++) {\n        domEach(this, (elem) => {\n            if (isTag(elem))\n                removeAttribute(elem, attrNames[i]);\n        });\n    }\n    return this;\n}\n/**\n * Check to see if _any_ of the matched elements have the given `className`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').hasClass('pear');\n * //=> true\n *\n * $('apple').hasClass('fruit');\n * //=> false\n *\n * $('li').hasClass('pear');\n * //=> true\n * ```\n *\n * @param className - Name of the class.\n * @returns Indicates if an element has the given `className`.\n * @see {@link https://api.jquery.com/hasClass/}\n */\nexport function hasClass(className) {\n    return this.toArray().some((elem) => {\n        const clazz = isTag(elem) && elem.attribs['class'];\n        let idx = -1;\n        if (clazz && className.length) {\n            while ((idx = clazz.indexOf(className, idx + 1)) > -1) {\n                const end = idx + className.length;\n                if ((idx === 0 || rspace.test(clazz[idx - 1])) &&\n                    (end === clazz.length || rspace.test(clazz[end]))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    });\n}\n/**\n * Adds class(es) to all of the matched elements. Also accepts a `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').addClass('fruit').html();\n * //=> <li class=\"pear fruit\">Pear</li>\n *\n * $('.apple').addClass('fruit red').html();\n * //=> <li class=\"apple fruit red\">Apple</li>\n * ```\n *\n * @param value - Name of new class.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/addClass/}\n */\nexport function addClass(value) {\n    // Support functions\n    if (typeof value === 'function') {\n        return domEach(this, (el, i) => {\n            if (isTag(el)) {\n                const className = el.attribs['class'] || '';\n                addClass.call([el], value.call(el, i, className));\n            }\n        });\n    }\n    // Return if no value or not a string or function\n    if (!value || typeof value !== 'string')\n        return this;\n    const classNames = value.split(rspace);\n    const numElements = this.length;\n    for (let i = 0; i < numElements; i++) {\n        const el = this[i];\n        // If selected element isn't a tag, move on\n        if (!isTag(el))\n            continue;\n        // If we don't already have classes — always set xmlMode to false here, as it doesn't matter for classes\n        const className = getAttr(el, 'class', false);\n        if (!className) {\n            setAttr(el, 'class', classNames.join(' ').trim());\n        }\n        else {\n            let setClass = ` ${className} `;\n            // Check if class already exists\n            for (let j = 0; j < classNames.length; j++) {\n                const appendClass = `${classNames[j]} `;\n                if (!setClass.includes(` ${appendClass}`))\n                    setClass += appendClass;\n            }\n            setAttr(el, 'class', setClass.trim());\n        }\n    }\n    return this;\n}\n/**\n * Removes one or more space-separated classes from the selected elements. If no\n * `className` is defined, all classes will be removed. Also accepts a `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').removeClass('pear').html();\n * //=> <li class=\"\">Pear</li>\n *\n * $('.apple').addClass('red').removeClass().html();\n * //=> <li class=\"\">Apple</li>\n * ```\n *\n * @param name - Name of the class. If not specified, removes all elements.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/removeClass/}\n */\nexport function removeClass(name) {\n    // Handle if value is a function\n    if (typeof name === 'function') {\n        return domEach(this, (el, i) => {\n            if (isTag(el)) {\n                removeClass.call([el], name.call(el, i, el.attribs['class'] || ''));\n            }\n        });\n    }\n    const classes = splitNames(name);\n    const numClasses = classes.length;\n    const removeAll = arguments.length === 0;\n    return domEach(this, (el) => {\n        if (!isTag(el))\n            return;\n        if (removeAll) {\n            // Short circuit the remove all case as this is the nice one\n            el.attribs['class'] = '';\n        }\n        else {\n            const elClasses = splitNames(el.attribs['class']);\n            let changed = false;\n            for (let j = 0; j < numClasses; j++) {\n                const index = elClasses.indexOf(classes[j]);\n                if (index >= 0) {\n                    elClasses.splice(index, 1);\n                    changed = true;\n                    /*\n                     * We have to do another pass to ensure that there are not duplicate\n                     * classes listed\n                     */\n                    j--;\n                }\n            }\n            if (changed) {\n                el.attribs['class'] = elClasses.join(' ');\n            }\n        }\n    });\n}\n/**\n * Add or remove class(es) from the matched elements, depending on either the\n * class's presence or the value of the switch argument. Also accepts a `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.apple.green').toggleClass('fruit green red').html();\n * //=> <li class=\"apple fruit red\">Apple</li>\n *\n * $('.apple.green').toggleClass('fruit green red', true).html();\n * //=> <li class=\"apple green fruit red\">Apple</li>\n * ```\n *\n * @param value - Name of the class. Can also be a function.\n * @param stateVal - If specified the state of the class.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/toggleClass/}\n */\nexport function toggleClass(value, stateVal) {\n    // Support functions\n    if (typeof value === 'function') {\n        return domEach(this, (el, i) => {\n            if (isTag(el)) {\n                toggleClass.call([el], value.call(el, i, el.attribs['class'] || '', stateVal), stateVal);\n            }\n        });\n    }\n    // Return if no value or not a string or function\n    if (!value || typeof value !== 'string')\n        return this;\n    const classNames = value.split(rspace);\n    const numClasses = classNames.length;\n    const state = typeof stateVal === 'boolean' ? (stateVal ? 1 : -1) : 0;\n    const numElements = this.length;\n    for (let i = 0; i < numElements; i++) {\n        const el = this[i];\n        // If selected element isn't a tag, move on\n        if (!isTag(el))\n            continue;\n        const elementClasses = splitNames(el.attribs['class']);\n        // Check if class already exists\n        for (let j = 0; j < numClasses; j++) {\n            // Check if the class name is currently defined\n            const index = elementClasses.indexOf(classNames[j]);\n            // Add if stateValue === true or we are toggling and there is no value\n            if (state >= 0 && index < 0) {\n                elementClasses.push(classNames[j]);\n            }\n            else if (state <= 0 && index >= 0) {\n                // Otherwise remove but only if the item exists\n                elementClasses.splice(index, 1);\n            }\n        }\n        el.attribs['class'] = elementClasses.join(' ');\n    }\n    return this;\n}\n//# sourceMappingURL=attributes.js.map"]},"metadata":{},"sourceType":"module"}