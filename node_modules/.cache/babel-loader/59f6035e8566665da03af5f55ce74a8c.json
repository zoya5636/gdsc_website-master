{"ast":null,"code":"import htmlTrie from \"./generated/encode-html.js\";\nimport { xmlReplacer, getCodePoint } from \"./escape.js\";\nconst htmlReplacer = /[\\t\\n!-,./:-@[-`\\f{-}$\\x80-\\uFFFF]/g;\n/**\n * Encodes all characters in the input using HTML entities. This includes\n * characters that are valid ASCII characters in HTML documents, such as `#`.\n *\n * To get a more compact output, consider using the `encodeNonAsciiHTML`\n * function, which will only encode characters that are not valid in HTML\n * documents, as well as non-ASCII characters.\n *\n * If a character has no equivalent entity, a numeric hexadecimal reference\n * (eg. `&#xfc;`) will be used.\n */\n\nexport function encodeHTML(data) {\n  return encodeHTMLTrieRe(htmlReplacer, data);\n}\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities. This function will not encode characters that\n * are valid in HTML documents, such as `#`.\n *\n * If a character has no equivalent entity, a numeric hexadecimal reference\n * (eg. `&#xfc;`) will be used.\n */\n\nexport function encodeNonAsciiHTML(data) {\n  return encodeHTMLTrieRe(xmlReplacer, data);\n}\n\nfunction encodeHTMLTrieRe(regExp, str) {\n  let ret = \"\";\n  let lastIdx = 0;\n  let match;\n\n  while ((match = regExp.exec(str)) !== null) {\n    const i = match.index;\n    ret += str.substring(lastIdx, i);\n    const char = str.charCodeAt(i);\n    let next = htmlTrie.get(char);\n\n    if (typeof next === \"object\") {\n      // We are in a branch. Try to match the next char.\n      if (i + 1 < str.length) {\n        const nextChar = str.charCodeAt(i + 1);\n        const value = typeof next.n === \"number\" ? next.n === nextChar ? next.o : undefined : next.n.get(nextChar);\n\n        if (value !== undefined) {\n          ret += value;\n          lastIdx = regExp.lastIndex += 1;\n          continue;\n        }\n      }\n\n      next = next.v;\n    } // We might have a tree node without a value; skip and use a numeric entitiy.\n\n\n    if (next !== undefined) {\n      ret += next;\n      lastIdx = i + 1;\n    } else {\n      const cp = getCodePoint(str, i);\n      ret += `&#x${cp.toString(16)};`; // Increase by 1 if we have a surrogate pair\n\n      lastIdx = regExp.lastIndex += Number(cp !== char);\n    }\n  }\n\n  return ret + str.substr(lastIdx);\n}","map":{"version":3,"sources":["encode.ts"],"names":[],"mappings":"AAAA,OAAO,QAAP,MAAqB,4BAArB;AACA,SAAS,WAAT,EAAsB,YAAtB,QAA0C,aAA1C;AAEA,MAAM,YAAY,GAAG,qCAArB;AAEA;;;;;;;;;;AAUG;;AACH,OAAM,SAAU,UAAV,CAAqB,IAArB,EAAiC;AACnC,SAAO,gBAAgB,CAAC,YAAD,EAAe,IAAf,CAAvB;AACH;AACD;;;;;;;AAOG;;AACH,OAAM,SAAU,kBAAV,CAA6B,IAA7B,EAAyC;AAC3C,SAAO,gBAAgB,CAAC,WAAD,EAAc,IAAd,CAAvB;AACH;;AAED,SAAS,gBAAT,CAA0B,MAA1B,EAA0C,GAA1C,EAAqD;AACjD,MAAI,GAAG,GAAG,EAAV;AACA,MAAI,OAAO,GAAG,CAAd;AACA,MAAI,KAAJ;;AAEA,SAAO,CAAC,KAAK,GAAG,MAAM,CAAC,IAAP,CAAY,GAAZ,CAAT,MAA+B,IAAtC,EAA4C;AACxC,UAAM,CAAC,GAAG,KAAK,CAAC,KAAhB;AACA,IAAA,GAAG,IAAI,GAAG,CAAC,SAAJ,CAAc,OAAd,EAAuB,CAAvB,CAAP;AACA,UAAM,IAAI,GAAG,GAAG,CAAC,UAAJ,CAAe,CAAf,CAAb;AACA,QAAI,IAAI,GAAG,QAAQ,CAAC,GAAT,CAAa,IAAb,CAAX;;AAEA,QAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC1B;AACA,UAAI,CAAC,GAAG,CAAJ,GAAQ,GAAG,CAAC,MAAhB,EAAwB;AACpB,cAAM,QAAQ,GAAG,GAAG,CAAC,UAAJ,CAAe,CAAC,GAAG,CAAnB,CAAjB;AACA,cAAM,KAAK,GACP,OAAO,IAAI,CAAC,CAAZ,KAAkB,QAAlB,GACM,IAAI,CAAC,CAAL,KAAW,QAAX,GACI,IAAI,CAAC,CADT,GAEI,SAHV,GAIM,IAAI,CAAC,CAAL,CAAO,GAAP,CAAW,QAAX,CALV;;AAOA,YAAI,KAAK,KAAK,SAAd,EAAyB;AACrB,UAAA,GAAG,IAAI,KAAP;AACA,UAAA,OAAO,GAAG,MAAM,CAAC,SAAP,IAAoB,CAA9B;AACA;AACH;AACJ;;AAED,MAAA,IAAI,GAAG,IAAI,CAAC,CAAZ;AACH,KAzBuC,CA2BxC;;;AACA,QAAI,IAAI,KAAK,SAAb,EAAwB;AACpB,MAAA,GAAG,IAAI,IAAP;AACA,MAAA,OAAO,GAAG,CAAC,GAAG,CAAd;AACH,KAHD,MAGO;AACH,YAAM,EAAE,GAAG,YAAY,CAAC,GAAD,EAAM,CAAN,CAAvB;AACA,MAAA,GAAG,IAAI,MAAM,EAAE,CAAC,QAAH,CAAY,EAAZ,CAAe,GAA5B,CAFG,CAGH;;AACA,MAAA,OAAO,GAAG,MAAM,CAAC,SAAP,IAAoB,MAAM,CAAC,EAAE,KAAK,IAAR,CAApC;AACH;AACJ;;AAED,SAAO,GAAG,GAAG,GAAG,CAAC,MAAJ,CAAW,OAAX,CAAb;AACH","sourceRoot":"https://raw.githubusercontent.com/fb55/entities/867ac709ba482a56a98b7c35f49ca833c74dc193/src/","sourcesContent":["import htmlTrie from \"./generated/encode-html.js\";\nimport { xmlReplacer, getCodePoint } from \"./escape.js\";\nconst htmlReplacer = /[\\t\\n!-,./:-@[-`\\f{-}$\\x80-\\uFFFF]/g;\n/**\n * Encodes all characters in the input using HTML entities. This includes\n * characters that are valid ASCII characters in HTML documents, such as `#`.\n *\n * To get a more compact output, consider using the `encodeNonAsciiHTML`\n * function, which will only encode characters that are not valid in HTML\n * documents, as well as non-ASCII characters.\n *\n * If a character has no equivalent entity, a numeric hexadecimal reference\n * (eg. `&#xfc;`) will be used.\n */\nexport function encodeHTML(data) {\n    return encodeHTMLTrieRe(htmlReplacer, data);\n}\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities. This function will not encode characters that\n * are valid in HTML documents, such as `#`.\n *\n * If a character has no equivalent entity, a numeric hexadecimal reference\n * (eg. `&#xfc;`) will be used.\n */\nexport function encodeNonAsciiHTML(data) {\n    return encodeHTMLTrieRe(xmlReplacer, data);\n}\nfunction encodeHTMLTrieRe(regExp, str) {\n    let ret = \"\";\n    let lastIdx = 0;\n    let match;\n    while ((match = regExp.exec(str)) !== null) {\n        const i = match.index;\n        ret += str.substring(lastIdx, i);\n        const char = str.charCodeAt(i);\n        let next = htmlTrie.get(char);\n        if (typeof next === \"object\") {\n            // We are in a branch. Try to match the next char.\n            if (i + 1 < str.length) {\n                const nextChar = str.charCodeAt(i + 1);\n                const value = typeof next.n === \"number\"\n                    ? next.n === nextChar\n                        ? next.o\n                        : undefined\n                    : next.n.get(nextChar);\n                if (value !== undefined) {\n                    ret += value;\n                    lastIdx = regExp.lastIndex += 1;\n                    continue;\n                }\n            }\n            next = next.v;\n        }\n        // We might have a tree node without a value; skip and use a numeric entitiy.\n        if (next !== undefined) {\n            ret += next;\n            lastIdx = i + 1;\n        }\n        else {\n            const cp = getCodePoint(str, i);\n            ret += `&#x${cp.toString(16)};`;\n            // Increase by 1 if we have a surrogate pair\n            lastIdx = regExp.lastIndex += Number(cp !== char);\n        }\n    }\n    return ret + str.substr(lastIdx);\n}\n//# sourceMappingURL=encode.js.map"]},"metadata":{},"sourceType":"module"}