{"ast":null,"code":"import { isTag, isText } from \"domhandler\";\nimport { filter, findOne } from \"./querying.js\";\nconst Checks = {\n  tag_name(name) {\n    if (typeof name === \"function\") {\n      return elem => isTag(elem) && name(elem.name);\n    } else if (name === \"*\") {\n      return isTag;\n    }\n\n    return elem => isTag(elem) && elem.name === name;\n  },\n\n  tag_type(type) {\n    if (typeof type === \"function\") {\n      return elem => type(elem.type);\n    }\n\n    return elem => elem.type === type;\n  },\n\n  tag_contains(data) {\n    if (typeof data === \"function\") {\n      return elem => isText(elem) && data(elem.data);\n    }\n\n    return elem => isText(elem) && elem.data === data;\n  }\n\n};\n/**\n * @param attrib Attribute to check.\n * @param value Attribute value to look for.\n * @returns A function to check whether the a node has an attribute with a\n *   particular value.\n */\n\nfunction getAttribCheck(attrib, value) {\n  if (typeof value === \"function\") {\n    return elem => isTag(elem) && value(elem.attribs[attrib]);\n  }\n\n  return elem => isTag(elem) && elem.attribs[attrib] === value;\n}\n/**\n * @param a First function to combine.\n * @param b Second function to combine.\n * @returns A function taking a node and returning `true` if either of the input\n *   functions returns `true` for the node.\n */\n\n\nfunction combineFuncs(a, b) {\n  return elem => a(elem) || b(elem);\n}\n/**\n * @param options An object describing nodes to look for.\n * @returns A function executing all checks in `options` and returning `true` if\n *   any of them match a node.\n */\n\n\nfunction compileTest(options) {\n  const funcs = Object.keys(options).map(key => {\n    const value = options[key];\n    return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);\n  });\n  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);\n}\n/**\n * @category Legacy Query Functions\n * @param options An object describing nodes to look for.\n * @param node The element to test.\n * @returns Whether the element matches the description in `options`.\n */\n\n\nexport function testElement(options, node) {\n  const test = compileTest(options);\n  return test ? test(node) : true;\n}\n/**\n * @category Legacy Query Functions\n * @param options An object describing nodes to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes that match `options`.\n */\n\nexport function getElements(options, nodes, recurse, limit = Infinity) {\n  const test = compileTest(options);\n  return test ? filter(test, nodes, recurse, limit) : [];\n}\n/**\n * @category Legacy Query Functions\n * @param id The unique ID attribute value to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @returns The node with the supplied ID.\n */\n\nexport function getElementById(id, nodes, recurse = true) {\n  if (!Array.isArray(nodes)) nodes = [nodes];\n  return findOne(getAttribCheck(\"id\", id), nodes, recurse);\n}\n/**\n * @category Legacy Query Functions\n * @param tagName Tag name to search for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes with the supplied `tagName`.\n */\n\nexport function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {\n  return filter(Checks[\"tag_name\"](tagName), nodes, recurse, limit);\n}\n/**\n * @category Legacy Query Functions\n * @param type Element type to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes with the supplied `type`.\n */\n\nexport function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {\n  return filter(Checks[\"tag_type\"](type), nodes, recurse, limit);\n}","map":{"version":3,"sources":["legacy.ts"],"names":[],"mappings":"AAAA,SAAS,KAAT,EAAgB,MAAhB,QAAgD,YAAhD;AAEA,SAAS,MAAT,EAAiB,OAAjB,QAAgC,eAAhC;AAqBA,MAAM,MAAM,GAGR;AACA,EAAA,QAAQ,CAAC,IAAD,EAAK;AACT,QAAI,OAAO,IAAP,KAAgB,UAApB,EAAgC;AAC5B,aAAQ,IAAD,IAAmB,KAAK,CAAC,IAAD,CAAL,IAAe,IAAI,CAAC,IAAI,CAAC,IAAN,CAA7C;AACH,KAFD,MAEO,IAAI,IAAI,KAAK,GAAb,EAAkB;AACrB,aAAO,KAAP;AACH;;AACD,WAAQ,IAAD,IAAmB,KAAK,CAAC,IAAD,CAAL,IAAe,IAAI,CAAC,IAAL,KAAc,IAAvD;AACH,GARD;;AASA,EAAA,QAAQ,CAAC,IAAD,EAAK;AACT,QAAI,OAAO,IAAP,KAAgB,UAApB,EAAgC;AAC5B,aAAQ,IAAD,IAAmB,IAAI,CAAC,IAAI,CAAC,IAAN,CAA9B;AACH;;AACD,WAAQ,IAAD,IAAmB,IAAI,CAAC,IAAL,KAAc,IAAxC;AACH,GAdD;;AAeA,EAAA,YAAY,CAAC,IAAD,EAAK;AACb,QAAI,OAAO,IAAP,KAAgB,UAApB,EAAgC;AAC5B,aAAQ,IAAD,IAAmB,MAAM,CAAC,IAAD,CAAN,IAAgB,IAAI,CAAC,IAAI,CAAC,IAAN,CAA9C;AACH;;AACD,WAAQ,IAAD,IAAmB,MAAM,CAAC,IAAD,CAAN,IAAgB,IAAI,CAAC,IAAL,KAAc,IAAxD;AACH;;AApBD,CAHJ;AA0BA;;;;;AAKG;;AACH,SAAS,cAAT,CACI,MADJ,EAEI,KAFJ,EAE4D;AAExD,MAAI,OAAO,KAAP,KAAiB,UAArB,EAAiC;AAC7B,WAAQ,IAAD,IAAmB,KAAK,CAAC,IAAD,CAAL,IAAe,KAAK,CAAC,IAAI,CAAC,OAAL,CAAa,MAAb,CAAD,CAA9C;AACH;;AACD,SAAQ,IAAD,IAAmB,KAAK,CAAC,IAAD,CAAL,IAAe,IAAI,CAAC,OAAL,CAAa,MAAb,MAAyB,KAAlE;AACH;AAED;;;;;AAKG;;;AACH,SAAS,YAAT,CAAsB,CAAtB,EAAmC,CAAnC,EAA8C;AAC1C,SAAQ,IAAD,IAAmB,CAAC,CAAC,IAAD,CAAD,IAAW,CAAC,CAAC,IAAD,CAAtC;AACH;AAED;;;;AAIG;;;AACH,SAAS,WAAT,CAAqB,OAArB,EAA6C;AACzC,QAAM,KAAK,GAAG,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,GAArB,CAA0B,GAAD,IAAQ;AAC3C,UAAM,KAAK,GAAG,OAAO,CAAC,GAAD,CAArB;AACA,WAAO,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,MAArC,EAA6C,GAA7C,IACD,MAAM,CAAC,GAAD,CAAN,CAAY,KAAZ,CADC,GAED,cAAc,CAAC,GAAD,EAAM,KAAN,CAFpB;AAGH,GALa,CAAd;AAOA,SAAO,KAAK,CAAC,MAAN,KAAiB,CAAjB,GAAqB,IAArB,GAA4B,KAAK,CAAC,MAAN,CAAa,YAAb,CAAnC;AACH;AAED;;;;;AAKG;;;AACH,OAAM,SAAU,WAAV,CAAsB,OAAtB,EAAgD,IAAhD,EAA6D;AAC/D,QAAM,IAAI,GAAG,WAAW,CAAC,OAAD,CAAxB;AACA,SAAO,IAAI,GAAG,IAAI,CAAC,IAAD,CAAP,GAAgB,IAA3B;AACH;AAED;;;;;;;AAOG;;AACH,OAAM,SAAU,WAAV,CACF,OADE,EAEF,KAFE,EAGF,OAHE,EAIF,KAAK,GAAG,QAJN,EAIc;AAEhB,QAAM,IAAI,GAAG,WAAW,CAAC,OAAD,CAAxB;AACA,SAAO,IAAI,GAAG,MAAM,CAAC,IAAD,EAAO,KAAP,EAAc,OAAd,EAAuB,KAAvB,CAAT,GAAyC,EAApD;AACH;AAED;;;;;;AAMG;;AACH,OAAM,SAAU,cAAV,CACF,EADE,EAEF,KAFE,EAGF,OAAO,GAAG,IAHR,EAGY;AAEd,MAAI,CAAC,KAAK,CAAC,OAAN,CAAc,KAAd,CAAL,EAA2B,KAAK,GAAG,CAAC,KAAD,CAAR;AAC3B,SAAO,OAAO,CAAC,cAAc,CAAC,IAAD,EAAO,EAAP,CAAf,EAA2B,KAA3B,EAAkC,OAAlC,CAAd;AACH;AAED;;;;;;;AAOG;;AACH,OAAM,SAAU,oBAAV,CACF,OADE,EAEF,KAFE,EAGF,OAAO,GAAG,IAHR,EAIF,KAAK,GAAG,QAJN,EAIc;AAEhB,SAAO,MAAM,CACT,MAAM,CAAC,UAAD,CAAN,CAAmB,OAAnB,CADS,EAET,KAFS,EAGT,OAHS,EAIT,KAJS,CAAb;AAMH;AAED;;;;;;;AAOG;;AACH,OAAM,SAAU,oBAAV,CACF,IADE,EAEF,KAFE,EAGF,OAAO,GAAG,IAHR,EAIF,KAAK,GAAG,QAJN,EAIc;AAEhB,SAAO,MAAM,CAAC,MAAM,CAAC,UAAD,CAAN,CAAmB,IAAnB,CAAD,EAAqC,KAArC,EAA4C,OAA5C,EAAqD,KAArD,CAAb;AACH","sourceRoot":"https://raw.githubusercontent.com/fb55/domutils/f7e357b5c210b6731c2a60e0b7b3cfaa1f96b706/src/","sourcesContent":["import { isTag, isText } from \"domhandler\";\nimport { filter, findOne } from \"./querying.js\";\nconst Checks = {\n    tag_name(name) {\n        if (typeof name === \"function\") {\n            return (elem) => isTag(elem) && name(elem.name);\n        }\n        else if (name === \"*\") {\n            return isTag;\n        }\n        return (elem) => isTag(elem) && elem.name === name;\n    },\n    tag_type(type) {\n        if (typeof type === \"function\") {\n            return (elem) => type(elem.type);\n        }\n        return (elem) => elem.type === type;\n    },\n    tag_contains(data) {\n        if (typeof data === \"function\") {\n            return (elem) => isText(elem) && data(elem.data);\n        }\n        return (elem) => isText(elem) && elem.data === data;\n    },\n};\n/**\n * @param attrib Attribute to check.\n * @param value Attribute value to look for.\n * @returns A function to check whether the a node has an attribute with a\n *   particular value.\n */\nfunction getAttribCheck(attrib, value) {\n    if (typeof value === \"function\") {\n        return (elem) => isTag(elem) && value(elem.attribs[attrib]);\n    }\n    return (elem) => isTag(elem) && elem.attribs[attrib] === value;\n}\n/**\n * @param a First function to combine.\n * @param b Second function to combine.\n * @returns A function taking a node and returning `true` if either of the input\n *   functions returns `true` for the node.\n */\nfunction combineFuncs(a, b) {\n    return (elem) => a(elem) || b(elem);\n}\n/**\n * @param options An object describing nodes to look for.\n * @returns A function executing all checks in `options` and returning `true` if\n *   any of them match a node.\n */\nfunction compileTest(options) {\n    const funcs = Object.keys(options).map((key) => {\n        const value = options[key];\n        return Object.prototype.hasOwnProperty.call(Checks, key)\n            ? Checks[key](value)\n            : getAttribCheck(key, value);\n    });\n    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);\n}\n/**\n * @category Legacy Query Functions\n * @param options An object describing nodes to look for.\n * @param node The element to test.\n * @returns Whether the element matches the description in `options`.\n */\nexport function testElement(options, node) {\n    const test = compileTest(options);\n    return test ? test(node) : true;\n}\n/**\n * @category Legacy Query Functions\n * @param options An object describing nodes to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes that match `options`.\n */\nexport function getElements(options, nodes, recurse, limit = Infinity) {\n    const test = compileTest(options);\n    return test ? filter(test, nodes, recurse, limit) : [];\n}\n/**\n * @category Legacy Query Functions\n * @param id The unique ID attribute value to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @returns The node with the supplied ID.\n */\nexport function getElementById(id, nodes, recurse = true) {\n    if (!Array.isArray(nodes))\n        nodes = [nodes];\n    return findOne(getAttribCheck(\"id\", id), nodes, recurse);\n}\n/**\n * @category Legacy Query Functions\n * @param tagName Tag name to search for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes with the supplied `tagName`.\n */\nexport function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {\n    return filter(Checks[\"tag_name\"](tagName), nodes, recurse, limit);\n}\n/**\n * @category Legacy Query Functions\n * @param type Element type to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes with the supplied `type`.\n */\nexport function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {\n    return filter(Checks[\"tag_type\"](type), nodes, recurse, limit);\n}\n//# sourceMappingURL=legacy.js.map"]},"metadata":{},"sourceType":"module"}