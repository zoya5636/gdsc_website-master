{"ast":null,"code":"import boolbase from \"boolbase\";\nimport { isTraversal } from \"../sort.js\";\n/** Used as a placeholder for :has. Will be replaced with the actual element. */\n\nexport const PLACEHOLDER_ELEMENT = {};\nexport function ensureIsTag(next, adapter) {\n  if (next === boolbase.falseFunc) return boolbase.falseFunc;\n  return elem => adapter.isTag(elem) && next(elem);\n}\nexport function getNextSiblings(elem, adapter) {\n  const siblings = adapter.getSiblings(elem);\n  if (siblings.length <= 1) return [];\n  const elemIndex = siblings.indexOf(elem);\n  if (elemIndex < 0 || elemIndex === siblings.length - 1) return [];\n  return siblings.slice(elemIndex + 1).filter(adapter.isTag);\n}\n\nfunction copyOptions(options) {\n  // Not copied: context, rootFunc\n  return {\n    xmlMode: !!options.xmlMode,\n    lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,\n    lowerCaseTags: !!options.lowerCaseTags,\n    quirksMode: !!options.quirksMode,\n    cacheResults: !!options.cacheResults,\n    pseudos: options.pseudos,\n    adapter: options.adapter,\n    equals: options.equals\n  };\n}\n\nconst is = (next, token, options, context, compileToken) => {\n  const func = compileToken(token, copyOptions(options), context);\n  return func === boolbase.trueFunc ? next : func === boolbase.falseFunc ? boolbase.falseFunc : elem => func(elem) && next(elem);\n};\n/*\n * :not, :has, :is, :matches and :where have to compile selectors\n * doing this in src/pseudos.ts would lead to circular dependencies,\n * so we add them here\n */\n\n\nexport const subselects = {\n  is,\n\n  /**\n   * `:matches` and `:where` are aliases for `:is`.\n   */\n  matches: is,\n  where: is,\n\n  not(next, token, options, context, compileToken) {\n    const func = compileToken(token, copyOptions(options), context);\n    return func === boolbase.falseFunc ? next : func === boolbase.trueFunc ? boolbase.falseFunc : elem => !func(elem) && next(elem);\n  },\n\n  has(next, subselect, options, _context, compileToken) {\n    const {\n      adapter\n    } = options;\n    const opts = copyOptions(options);\n    opts.relativeSelector = true;\n    const context = subselect.some(s => s.some(isTraversal)) ? // Used as a placeholder. Will be replaced with the actual element.\n    [PLACEHOLDER_ELEMENT] : undefined;\n    const compiled = compileToken(subselect, opts, context);\n    if (compiled === boolbase.falseFunc) return boolbase.falseFunc;\n    const hasElement = ensureIsTag(compiled, adapter); // If `compiled` is `trueFunc`, we can skip this.\n\n    if (context && compiled !== boolbase.trueFunc) {\n      /*\n       * `shouldTestNextSiblings` will only be true if the query starts with\n       * a traversal (sibling or adjacent). That means we will always have a context.\n       */\n      const {\n        shouldTestNextSiblings = false\n      } = compiled;\n      return elem => {\n        if (!next(elem)) return false;\n        context[0] = elem;\n        const childs = adapter.getChildren(elem);\n        const nextElements = shouldTestNextSiblings ? [...childs, ...getNextSiblings(elem, adapter)] : childs;\n        return adapter.existsOne(hasElement, nextElements);\n      };\n    }\n\n    return elem => next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));\n  }\n\n};","map":{"version":3,"sources":["pseudo-selectors/subselects.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/css-select/0f0725a9dfeddd2fdb54eda9656cdbab5bbf6be6/src/","sourcesContent":["import boolbase from \"boolbase\";\nimport { isTraversal } from \"../sort.js\";\n/** Used as a placeholder for :has. Will be replaced with the actual element. */\nexport const PLACEHOLDER_ELEMENT = {};\nexport function ensureIsTag(next, adapter) {\n    if (next === boolbase.falseFunc)\n        return boolbase.falseFunc;\n    return (elem) => adapter.isTag(elem) && next(elem);\n}\nexport function getNextSiblings(elem, adapter) {\n    const siblings = adapter.getSiblings(elem);\n    if (siblings.length <= 1)\n        return [];\n    const elemIndex = siblings.indexOf(elem);\n    if (elemIndex < 0 || elemIndex === siblings.length - 1)\n        return [];\n    return siblings.slice(elemIndex + 1).filter(adapter.isTag);\n}\nfunction copyOptions(options) {\n    // Not copied: context, rootFunc\n    return {\n        xmlMode: !!options.xmlMode,\n        lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,\n        lowerCaseTags: !!options.lowerCaseTags,\n        quirksMode: !!options.quirksMode,\n        cacheResults: !!options.cacheResults,\n        pseudos: options.pseudos,\n        adapter: options.adapter,\n        equals: options.equals,\n    };\n}\nconst is = (next, token, options, context, compileToken) => {\n    const func = compileToken(token, copyOptions(options), context);\n    return func === boolbase.trueFunc\n        ? next\n        : func === boolbase.falseFunc\n            ? boolbase.falseFunc\n            : (elem) => func(elem) && next(elem);\n};\n/*\n * :not, :has, :is, :matches and :where have to compile selectors\n * doing this in src/pseudos.ts would lead to circular dependencies,\n * so we add them here\n */\nexport const subselects = {\n    is,\n    /**\n     * `:matches` and `:where` are aliases for `:is`.\n     */\n    matches: is,\n    where: is,\n    not(next, token, options, context, compileToken) {\n        const func = compileToken(token, copyOptions(options), context);\n        return func === boolbase.falseFunc\n            ? next\n            : func === boolbase.trueFunc\n                ? boolbase.falseFunc\n                : (elem) => !func(elem) && next(elem);\n    },\n    has(next, subselect, options, _context, compileToken) {\n        const { adapter } = options;\n        const opts = copyOptions(options);\n        opts.relativeSelector = true;\n        const context = subselect.some((s) => s.some(isTraversal))\n            ? // Used as a placeholder. Will be replaced with the actual element.\n                [PLACEHOLDER_ELEMENT]\n            : undefined;\n        const compiled = compileToken(subselect, opts, context);\n        if (compiled === boolbase.falseFunc)\n            return boolbase.falseFunc;\n        const hasElement = ensureIsTag(compiled, adapter);\n        // If `compiled` is `trueFunc`, we can skip this.\n        if (context && compiled !== boolbase.trueFunc) {\n            /*\n             * `shouldTestNextSiblings` will only be true if the query starts with\n             * a traversal (sibling or adjacent). That means we will always have a context.\n             */\n            const { shouldTestNextSiblings = false } = compiled;\n            return (elem) => {\n                if (!next(elem))\n                    return false;\n                context[0] = elem;\n                const childs = adapter.getChildren(elem);\n                const nextElements = shouldTestNextSiblings\n                    ? [...childs, ...getNextSiblings(elem, adapter)]\n                    : childs;\n                return adapter.existsOne(hasElement, nextElements);\n            };\n        }\n        return (elem) => next(elem) &&\n            adapter.existsOne(hasElement, adapter.getChildren(elem));\n    },\n};\n//# sourceMappingURL=subselects.js.map"]},"metadata":{},"sourceType":"module"}