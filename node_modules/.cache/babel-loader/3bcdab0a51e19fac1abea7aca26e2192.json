{"ast":null,"code":"import { useForm } from 'react-hook-form';\nimport fetch from 'isomorphic-unfetch';\nimport { createContext, useContext, createElement, useState, useEffect } from 'react';\nimport slugify from 'slugify';\nimport cheerio from 'cheerio';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar getFieldFromContext = function (context, id, type) {\n  if (context === null) {\n    throw new Error('You need to wrap your form with a GoogleFormProvider');\n  }\n\n  var field = context.getField(id);\n\n  if (field.type !== type) {\n    throw new Error(\"Field with id \" + field.id + \" is not of type \" + type);\n  }\n\n  return field;\n};\n\nvar _excluded = [\"children\"];\nvar GoogleFormContext = createContext(null);\n\nvar useGoogleFormContext = function useGoogleFormContext() {\n  return useContext(GoogleFormContext);\n};\n\nvar GoogleFormProvider = function GoogleFormProvider(_ref) {\n  var children = _ref.children,\n      other = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  return createElement(GoogleFormContext.Provider, {\n    value: other\n  }, children);\n};\n\nvar OTHER_OPTION = '__other_option__';\nvar OTHER_OPTION_RESPONSE = 'other_option_response';\n\nvar buildCustomFieldId = function buildCustomFieldId(id) {\n  return id + \"-\" + OTHER_OPTION_RESPONSE;\n};\n\nvar useCustomOptionField = function (id, type) {\n  var context = useGoogleFormContext();\n  var field = getFieldFromContext(context, id, type);\n\n  var _useState = useState(false),\n      isCustomOptionSelected = _useState[0],\n      setIsCustomOptionSelected = _useState[1];\n\n  var _useState2 = useState(false),\n      customInputRequired = _useState2[0],\n      setCustomInputRequired = _useState2[1];\n\n  var register = function register(options) {\n    return context.register(id, _extends({\n      required: field.required\n    }, options));\n  };\n\n  var currentValue = context.watch(id);\n  useEffect(function () {\n    if (field.type === 'RADIO') {\n      var _isCustomOptionSelected = currentValue && currentValue === OTHER_OPTION;\n\n      setCustomInputRequired(field.required && _isCustomOptionSelected);\n      setIsCustomOptionSelected(_isCustomOptionSelected);\n    } else {\n      var _isCustomOptionSelected2 = currentValue && currentValue.length === 1 && currentValue.includes(OTHER_OPTION);\n\n      setCustomInputRequired(field.required && _isCustomOptionSelected2);\n      setIsCustomOptionSelected(_isCustomOptionSelected2);\n    }\n  }, [currentValue, customInputRequired]);\n  var nonCustomOptions = field.options.filter(function (o) {\n    return !o.custom;\n  });\n\n  var buildId = function buildId(value) {\n    return id + \"-\" + slugify(value);\n  };\n\n  var buildOptionRegister = function buildOptionRegister(o) {\n    var id = buildId(o.label);\n\n    var registerOption = function registerOption(options) {\n      return _extends({}, register(_extends({}, options)), {\n        value: o.label\n      });\n    };\n\n    return _extends({}, o, {\n      id: id,\n      registerOption: registerOption\n    });\n  };\n\n  var result = {\n    options: nonCustomOptions.map(buildOptionRegister)\n  };\n  var customOption = field.options.find(function (o) {\n    return o.custom;\n  });\n\n  if (customOption) {\n    var _id = buildId(OTHER_OPTION);\n\n    var registerOption = function registerOption(options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      return _extends({}, register(_extends({}, options)), {\n        value: OTHER_OPTION\n      });\n    };\n\n    var customOptionId = buildCustomFieldId(_id);\n\n    var registerCustomInput = function registerCustomInput(options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      return context.register(customOptionId, _extends({\n        required: customInputRequired\n      }, options));\n    };\n\n    var _error = context.formState.errors[customOptionId];\n    result.customOption = _extends({}, customOption, {\n      id: _id,\n      registerOption: registerOption,\n      registerCustomInput: registerCustomInput,\n      error: _error\n    });\n  }\n\n  var error = context.formState.errors[field.id];\n  return _extends({}, field, result, {\n    error: error,\n    isCustomOptionSelected: isCustomOptionSelected\n  });\n};\n\nvar GOOGLE_FORMS_URL = 'https://docs.google.com/forms/d';\n\nvar formatQuestionName = function formatQuestionName(id) {\n  if (id.includes(OTHER_OPTION_RESPONSE)) {\n    return \"entry.\" + id.replace(\"-\" + OTHER_OPTION + \"-\" + OTHER_OPTION_RESPONSE, '') + \".\" + OTHER_OPTION_RESPONSE;\n  }\n\n  return \"entry.\" + id;\n};\n\nvar submitToGoogleForms = function submitToGoogleForms(form, formData) {\n  try {\n    var urlParams = new URLSearchParams();\n    Object.keys(formData).forEach(function (key) {\n      if (formData[key]) {\n        if (formData[key].constructor === Array) {\n          formData[key].forEach(function (answer) {\n            urlParams.append(formatQuestionName(key), answer);\n          });\n        } else {\n          urlParams.append(formatQuestionName(key), formData[key]);\n        }\n      }\n    });\n    return Promise.resolve(fetch(GOOGLE_FORMS_URL + \"/\" + form.action + \"/formResponse?submit=Submit&\" + urlParams.toString(), {\n      method: 'GET',\n      mode: 'no-cors',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      }\n    })).then(function (fetchedResult) {\n      var wasSuccessful = fetchedResult.ok && fetchedResult.status < 300 && fetchedResult.status >= 200;\n      return wasSuccessful;\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar resolveField = function resolveField(id, form) {\n  var fieldIndex = form.fieldsOrder[id];\n\n  if (fieldIndex === undefined) {\n    throw new Error(\"Field with id \" + id + \" wasn't found in your form\");\n  }\n\n  var field = form.fields[fieldIndex];\n  return field;\n};\n\nvar useGoogleForm = function useGoogleForm(_ref) {\n  var form = _ref.form;\n  var methods = useForm();\n\n  methods.getField = function (id) {\n    return resolveField(id, form);\n  };\n\n  methods.submitToGoogleForms = function (formData) {\n    return submitToGoogleForms(form, formData);\n  };\n\n  return methods;\n};\n\nvar useRadioInput = function useRadioInput(id) {\n  return useCustomOptionField(id, 'RADIO');\n};\n\nvar useCheckboxInput = function useCheckboxInput(id) {\n  return useCustomOptionField(id, 'CHECKBOX');\n};\n\nvar useTextInput = function (id, fieldType) {\n  var context = useGoogleFormContext();\n  var field = getFieldFromContext(context, id, fieldType);\n  var error = context.formState.errors[field.id];\n\n  var register = function register(options) {\n    return context.register(id, _extends({\n      required: field.required\n    }, options));\n  };\n\n  return _extends({}, field, {\n    register: register,\n    error: error\n  });\n};\n\nvar useShortAnswerInput = function useShortAnswerInput(id) {\n  return useTextInput(id, 'SHORT_ANSWER');\n};\n\nvar useLongAnswerInput = function useLongAnswerInput(id) {\n  return useTextInput(id, 'LONG_ANSWER');\n};\n\nvar useGridInput = function (id, type) {\n  var context = useGoogleFormContext();\n\n  var _useState = useState(undefined),\n      errors = _useState[0],\n      setErrors = _useState[1];\n\n  var field = getFieldFromContext(context, id, type);\n\n  var buildId = function buildId(lineId, value) {\n    return id + \"-\" + lineId + \"-\" + slugify(value);\n  };\n\n  useEffect(function () {\n    var newErrors = field.lines.reduce(function (acc, l) {\n      var fieldError = context.formState.errors[l.id];\n\n      if (fieldError) {\n        acc[l.id] = fieldError;\n      }\n\n      return acc;\n    }, {});\n\n    if (Object.keys(newErrors).length > 0) {\n      setErrors(newErrors);\n    } else {\n      setErrors(undefined);\n    }\n  }, [context.formState.errors]);\n\n  var renderGrid = function renderGrid(render) {\n    return field.lines.map(function (l) {\n      var registerLine = function registerLine(options) {\n        return context.register(l.id, _extends({\n          required: field.required\n        }, options));\n      };\n\n      var renderColumns = function renderColumns(render) {\n        return field.columns.map(function (c) {\n          var id = buildId(l.id, c.label);\n\n          var registerColumn = function registerColumn(options) {\n            return _extends({}, registerLine(options), {\n              value: c.label\n            });\n          };\n\n          return render(_extends({}, c, {\n            registerColumn: registerColumn,\n            id: id\n          }));\n        });\n      };\n\n      return render(_extends({}, l, {\n        renderColumns: renderColumns\n      }));\n    });\n  };\n\n  return _extends({}, field, {\n    renderGrid: renderGrid,\n    errors: errors\n  });\n};\n\nvar useCheckboxGridInput = function useCheckboxGridInput(id) {\n  return useGridInput(id, 'CHECKBOX_GRID');\n};\n\nvar useRadioGridInput = function useRadioGridInput(id) {\n  return useGridInput(id, 'RADIO_GRID');\n};\n\nvar useDropdownInput = function useDropdownInput(id) {\n  var context = useGoogleFormContext();\n  var field = getFieldFromContext(context, id, 'DROPDOWN');\n\n  var register = function register(options) {\n    return context.register(id, _extends({\n      required: field.required\n    }, options));\n  };\n\n  var error = context.formState.errors[field.id];\n\n  var buildId = function buildId(value) {\n    return field.id + \"-\" + slugify(value);\n  };\n\n  var options = field.options.map(function (o) {\n    var id = buildId(o.label);\n    return _extends({}, o, {\n      id: id\n    });\n  });\n  return _extends({}, field, {\n    options: options,\n    register: register,\n    error: error\n  });\n};\n\nvar useLinearInput = function useLinearInput(id) {\n  var context = useGoogleFormContext();\n  var field = getFieldFromContext(context, id, 'LINEAR');\n\n  var register = function register(options) {\n    return context.register(id, _extends({\n      required: field.required\n    }, options));\n  };\n\n  var buildId = function buildId(value) {\n    return field.id + \"-\" + slugify(value);\n  };\n\n  var error = context.formState.errors[field.id];\n  var options = field.options.map(function (o) {\n    var id = buildId(o.label);\n\n    var registerOption = function registerOption(options) {\n      return _extends({}, register(options), {\n        value: o.label\n      });\n    };\n\n    return _extends({}, o, {\n      id: id,\n      registerOption: registerOption\n    });\n  });\n  return _extends({}, field, {\n    options: options,\n    error: error\n  });\n}; // A type of promise-like that resolves synchronously and supports only one observer\n\n\nconst _iteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\")) : \"@@iterator\";\n\nconst _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\")) : \"@@asyncIterator\"; // Asynchronously call a function and send errors to recovery continuation\n\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nvar toBool = function toBool(n) {\n  return n === 1;\n};\n\nvar toString = function toString(n) {\n  return \"\" + n;\n};\n\nvar assertValidUrl = function assertValidUrl(formUrl) {\n  var googleFormsHosts = ['docs.google.com', 'forms.gle'];\n  var url = new URL(formUrl);\n\n  if (!googleFormsHosts.includes(url.host)) {\n    throw new Error(\"Invalid google forms host. \" + url.host + \" is expected to be \" + googleFormsHosts.join(', ').replace(/, ([^,]*)$/, ' or $1') + \".\");\n  }\n\n  if (url.host === googleFormsHosts[0] && !url.pathname.endsWith('/viewform')) {\n    throw new Error(\"Please use the form's public URL.\");\n  }\n};\n\nvar getFormHtml = function getFormHtml(formUrl) {\n  try {\n    return Promise.resolve(fetch(formUrl)).then(function (response) {\n      return Promise.resolve(response.text());\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar extractFormData = function extractFormData(html) {\n  var $ = cheerio.load(html);\n  var fbzx = $('[name=\"fbzx\"]').attr('value');\n\n  if (!fbzx) {\n    throw new Error(\"Invalid form. Couldn't find fbzx field.\");\n  }\n\n  var scriptStringIdentifier = 'var FB_PUBLIC_LOAD_DATA_ =';\n  var scriptHtml = $('script').filter(function (_, el) {\n    return $(el).html().includes(scriptStringIdentifier);\n  }).first().html();\n\n  if (!scriptHtml) {\n    throw new Error(\"Invalid form. Couldn't find script tag.\");\n  }\n\n  scriptHtml = scriptHtml.slice(0, -1);\n  scriptHtml = scriptHtml.replace(scriptStringIdentifier, '');\n  var formDataRaw = JSON.parse(scriptHtml);\n  return {\n    formData: formDataRaw,\n    fbzx: fbzx\n  };\n};\n\nvar parseGridMultiSelect = function parseGridMultiSelect(rawField) {\n  var firstLine = rawField[4][0];\n  var canSelectMultiple = firstLine[11][0];\n  return canSelectMultiple;\n};\n\nvar parseFieldType = function parseFieldType(rawField, fieldId) {\n  var fieldTypes = ['SHORT_ANSWER', 'LONG_ANSWER', 'RADIO', 'DROPDOWN', 'CHECKBOX', 'LINEAR'];\n\n  if (fieldId === 7) {\n    if (parseGridMultiSelect(rawField) === 1) {\n      return 'CHECKBOX_GRID';\n    } else {\n      return 'RADIO_GRID';\n    }\n  }\n\n  if (fieldId === 9) {\n    return 'DATE';\n  }\n\n  return fieldTypes[fieldId];\n};\n\nvar parseOptions = function parseOptions(options) {\n  return options.map(function (rawOption) {\n    return {\n      label: rawOption[0]\n    };\n  });\n};\n\nvar parseCustomizableOptions = function parseCustomizableOptions(options) {\n  return options.map(function (rawOption) {\n    return {\n      label: rawOption[0],\n      custom: rawOption[4] === 1\n    };\n  });\n};\n\nvar flattenArray = function flattenArray(array) {\n  return array.map(function (item) {\n    return {\n      label: item[0]\n    };\n  });\n};\n\nvar parseLines = function parseLines(lines) {\n  return lines.map(function (rawLine) {\n    var line = {};\n    line.id = toString(rawLine[0]);\n    line.label = rawLine[3][0];\n    return line;\n  });\n};\n\nvar parseField = function parseField(rawField) {\n  var field = {};\n  field.label = rawField[1];\n  field.description = rawField[2];\n  var fieldId = rawField[3];\n  field.type = parseFieldType(rawField, fieldId);\n\n  switch (field.type) {\n    case 'SHORT_ANSWER':\n    case 'LONG_ANSWER':\n      {\n        var fieldInfo = rawField[4][0];\n        field.id = toString(fieldInfo[0]);\n        field.required = toBool(fieldInfo[2]);\n        break;\n      }\n\n    case 'CHECKBOX':\n    case 'RADIO':\n      {\n        var _fieldInfo = rawField[4][0];\n        field.id = toString(_fieldInfo[0]);\n        field.options = parseCustomizableOptions(_fieldInfo[1]);\n        field.required = toBool(_fieldInfo[2]);\n        break;\n      }\n\n    case 'DROPDOWN':\n      {\n        var _fieldInfo2 = rawField[4][0];\n        field.id = toString(_fieldInfo2[0]);\n        field.options = parseOptions(_fieldInfo2[1]);\n        field.required = toBool(_fieldInfo2[2]);\n        break;\n      }\n\n    case 'LINEAR':\n      {\n        var _fieldInfo3 = rawField[4][0];\n        field.id = toString(_fieldInfo3[0]);\n        var _fieldInfo3$ = _fieldInfo3[3],\n            labelFirst = _fieldInfo3$[0],\n            labelLast = _fieldInfo3$[1];\n        field.legend = {\n          labelFirst: labelFirst,\n          labelLast: labelLast\n        };\n        field.options = flattenArray(_fieldInfo3[1]);\n        field.required = toBool(_fieldInfo3[2]);\n        break;\n      }\n\n    case 'CHECKBOX_GRID':\n    case 'RADIO_GRID':\n      {\n        field.id = toString(rawField[0]);\n        field.columns = flattenArray(rawField[4][0][1]);\n        field.lines = parseLines(rawField[4]);\n        field.required = toBool(rawField[4][0][2]);\n        break;\n      }\n\n    case 'DATE':\n      {\n        var _fieldInfo4 = rawField[4][0];\n        field.id = toString(_fieldInfo4[0]);\n        field.required = toBool(rawField[4][0][2]);\n        break;\n      }\n  }\n\n  return field;\n};\n\nvar parseFields = function parseFields(rawFields) {\n  var fieldsOrder = {};\n  var fields = rawFields.map(function (rawField, i) {\n    var field = parseField(rawField);\n    fieldsOrder[\"\" + field.id] = i;\n    return field;\n  });\n  return {\n    fields: fields,\n    fieldsOrder: fieldsOrder\n  };\n};\n\nvar parseFormData = function parseFormData(_ref) {\n  var formData = _ref.formData,\n      fbzx = _ref.fbzx;\n  var googleForm = {};\n  googleForm.fvv = 1;\n  googleForm.pageHistory = 0;\n  googleForm.fbzx = fbzx;\n  googleForm.action = formData[14];\n  googleForm.title = formData[1][8];\n  googleForm.description = formData[1][0];\n\n  var _parseFields = parseFields(formData[1][1]),\n      fields = _parseFields.fields,\n      fieldsOrder = _parseFields.fieldsOrder;\n\n  googleForm.fields = fields;\n  googleForm.fieldsOrder = fieldsOrder;\n  return googleForm;\n};\n\nvar googleFormsToJson = function googleFormsToJson(formUrl) {\n  try {\n    var _exit2 = false;\n\n    var _temp3 = function _temp3(_result) {\n      if (_exit2) return _result;\n      var formData = extractFormData(html);\n      return parseFormData(formData);\n    };\n\n    assertValidUrl(formUrl);\n    var html;\n\n    var _temp4 = _catch(function () {\n      return Promise.resolve(getFormHtml(formUrl)).then(function (_getFormHtml) {\n        html = _getFormHtml;\n      });\n    }, function (err) {\n      throw new Error(\"Failed to fetch form. \" + err);\n    });\n\n    return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nexport { GOOGLE_FORMS_URL, GoogleFormProvider, formatQuestionName, googleFormsToJson, submitToGoogleForms, useCheckboxGridInput, useCheckboxInput, useDropdownInput, useGoogleForm, useGoogleFormContext, useLinearInput, useLongAnswerInput, useRadioGridInput, useRadioInput, useShortAnswerInput };","map":{"version":3,"sources":["../src/hooks/utils/getFieldFromContext.ts","../src/hooks/useGoogleFormContext.tsx","../src/hooks/utils/useCustomOptionField.ts","../src/scripts/submitToGoogleForms.ts","../src/hooks/useGoogleForm.ts","../src/hooks/useRadioInput.ts","../src/hooks/useCheckboxInput.ts","../src/hooks/utils/useTextInput.ts","../src/hooks/useShortAnswerInput.ts","../src/hooks/useLongAnswerInput.ts","../src/hooks/utils/useGridInput.ts","../src/hooks/useCheckboxGridInput.ts","../src/hooks/useRadioGridInput.ts","../src/hooks/useDropdownInput.ts","../src/hooks/useLinearInput.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/scripts/googleFormsToJson.ts"],"names":["context","field","GoogleFormContext","React","useGoogleFormContext","GoogleFormProvider","children","other","value","OTHER_OPTION","OTHER_OPTION_RESPONSE","buildCustomFieldId","id","getFieldFromContext","isCustomOptionSelected","setIsCustomOptionSelected","useState","customInputRequired","setCustomInputRequired","register","required","currentValue","useEffect","nonCustomOptions","o","buildId","slugify","buildOptionRegister","registerOption","label","result","options","customOption","customOptionId","registerCustomInput","error","GOOGLE_FORMS_URL","formatQuestionName","submitToGoogleForms","urlParams","Object","formData","fetchedResult","fetch","form","method","mode","headers","wasSuccessful","resolveField","fieldIndex","useGoogleForm","methods","useForm","useRadioInput","useCustomOptionField","useCheckboxInput","useShortAnswerInput","useTextInput","useLongAnswerInput","errors","setErrors","newErrors","fieldError","l","acc","renderGrid","registerLine","renderColumns","c","registerColumn","render","useCheckboxGridInput","useGridInput","useRadioGridInput","useDropdownInput","useLinearInput","toBool","n","toString","assertValidUrl","googleFormsHosts","url","getFormHtml","response","extractFormData","$","cheerio","fbzx","scriptStringIdentifier","scriptHtml","formDataRaw","JSON","parseGridMultiSelect","firstLine","rawField","canSelectMultiple","parseFieldType","fieldTypes","fieldId","parseOptions","rawOption","parseCustomizableOptions","custom","flattenArray","item","parseLines","line","rawLine","parseField","fieldInfo","labelFirst","labelLast","parseFields","fieldsOrder","fields","parseFormData","googleForm","googleFormsToJson","html","err"],"mappings":"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","sourcesContent":["import { UseGoogleFormReturn, FieldTypes } from '../../types'\n\nexport default (\n  context: UseGoogleFormReturn | null,\n  id: string,\n  type: FieldTypes\n) => {\n  if (context === null) {\n    throw new Error('You need to wrap your form with a GoogleFormProvider')\n  }\n\n  const field = context.getField(id)\n\n  if (field.type !== type) {\n    throw new Error(`Field with id ${field.id} is not of type ${type}`)\n  }\n\n  return field\n}\n","import * as React from 'react'\nimport { UseGoogleFormReturn } from '../types'\n\nconst GoogleFormContext = React.createContext<UseGoogleFormReturn | null>(null)\nexport const useGoogleFormContext = () => React.useContext(GoogleFormContext)\n\nexport const GoogleFormProvider = ({\n  children,\n  ...other\n}: {\n  children: React.ReactNode\n}) => {\n  return (\n    <GoogleFormContext.Provider value={other as UseGoogleFormReturn}>\n      {children}\n    </GoogleFormContext.Provider>\n  )\n}\n","import { useState, useEffect } from 'react'\nimport slugify from 'slugify'\n\nimport {\n  UseCustomOptionReturn,\n  Option,\n  BaseField,\n  UseCustomOptionField,\n  CustomOptionField\n} from '../../types'\nimport getFieldFromContext from './getFieldFromContext'\nimport { useGoogleFormContext } from '../useGoogleFormContext'\nimport { RegisterOptions } from 'react-hook-form'\n\nexport const OTHER_OPTION = '__other_option__'\nexport const OTHER_OPTION_RESPONSE = 'other_option_response'\n\nexport const buildCustomFieldId = (id: string) => {\n  return `${id}-${OTHER_OPTION_RESPONSE}`\n}\n\nexport default (\n  id: string,\n  type: 'CHECKBOX' | 'RADIO'\n): UseCustomOptionField => {\n  const context = useGoogleFormContext()\n  const field = getFieldFromContext(context, id, type) as CustomOptionField\n\n  const [isCustomOptionSelected, setIsCustomOptionSelected] =\n    useState<boolean>(false)\n  const [customInputRequired, setCustomInputRequired] = useState<boolean>(false)\n\n  const register = (options?: RegisterOptions) =>\n    context!.register(id, { required: field.required, ...options })\n\n  const currentValue = context!.watch(id)\n\n  useEffect(() => {\n    if (field.type === 'RADIO') {\n      const isCustomOptionSelected =\n        currentValue && currentValue === OTHER_OPTION\n      setCustomInputRequired(field.required && isCustomOptionSelected)\n      setIsCustomOptionSelected(isCustomOptionSelected)\n    } else {\n      const isCustomOptionSelected =\n        currentValue &&\n        currentValue.length === 1 &&\n        currentValue.includes(OTHER_OPTION)\n      setCustomInputRequired(field.required && isCustomOptionSelected)\n      setIsCustomOptionSelected(isCustomOptionSelected)\n    }\n  }, [currentValue, customInputRequired])\n\n  const nonCustomOptions = field.options.filter(\n    (o) => !o.custom\n  ) as Array<Option>\n\n  const buildId = (value: string) => {\n    return `${id}-${slugify(value)}`\n  }\n\n  const buildOptionRegister = (o: Option) => {\n    const id = buildId(o.label)\n    const registerOption = (options: RegisterOptions) => ({\n      ...register({ ...options }),\n      value: o.label\n    })\n\n    return {\n      ...o,\n      id,\n      registerOption\n    }\n  }\n\n  const result = {\n    options: nonCustomOptions.map(buildOptionRegister)\n  } as UseCustomOptionReturn\n\n  const customOption = field.options.find((o) => o.custom) as Option\n  if (customOption) {\n    const id = buildId(OTHER_OPTION)\n    const registerOption = (options = {}) => ({\n      ...register({ ...options }),\n      value: OTHER_OPTION\n    })\n\n    const customOptionId = buildCustomFieldId(id)\n\n    const registerCustomInput = (options = {}) => {\n      return context!.register(customOptionId, {\n        required: customInputRequired,\n        ...options\n      })\n    }\n\n    const error = context!.formState.errors[customOptionId]\n\n    result.customOption = {\n      ...customOption,\n      id,\n      registerOption,\n      registerCustomInput,\n      error\n    }\n  }\n\n  const error = context!.formState.errors[field.id]\n\n  return {\n    ...(field as BaseField),\n    ...result,\n    error,\n    isCustomOptionSelected\n  }\n}\n","import fetch from 'isomorphic-unfetch'\nimport { GoogleForm } from '../types'\nimport {\n  OTHER_OPTION,\n  OTHER_OPTION_RESPONSE\n} from '../hooks/utils/useCustomOptionField'\n\nexport const GOOGLE_FORMS_URL = 'https://docs.google.com/forms/d'\n\nexport const formatQuestionName = (id: string) => {\n  if (id.includes(OTHER_OPTION_RESPONSE)) {\n    return `entry.${id.replace(\n      `-${OTHER_OPTION}-${OTHER_OPTION_RESPONSE}`,\n      ''\n    )}.${OTHER_OPTION_RESPONSE}`\n  }\n\n  return `entry.${id}`\n}\n\nexport const submitToGoogleForms = async (\n  form: GoogleForm,\n  formData: object\n): Promise<boolean> => {\n  const urlParams = new URLSearchParams()\n  Object.keys(formData).forEach((key) => {\n    if (formData[key]) {\n      if (formData[key].constructor === Array) {\n        formData[key].forEach((answer: string) => {\n          urlParams.append(formatQuestionName(key), answer)\n        })\n      } else {\n        urlParams.append(formatQuestionName(key), formData[key])\n      }\n    }\n  })\n\n  const fetchedResult = await fetch(\n    `${GOOGLE_FORMS_URL}/${\n      form.action\n    }/formResponse?submit=Submit&${urlParams.toString()}`,\n    {\n      method: 'GET',\n      mode: 'no-cors',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      }\n    }\n  )\n\n  const wasSuccessful =\n    fetchedResult.ok &&\n    fetchedResult.status < 300 &&\n    fetchedResult.status >= 200\n\n  return wasSuccessful\n}\n","import { useForm } from 'react-hook-form'\nimport { GoogleForm, UseGoogleFormReturn } from '../types'\nimport { submitToGoogleForms } from '../scripts/submitToGoogleForms'\n\nconst resolveField = (id: string, form: GoogleForm) => {\n  const fieldIndex = form.fieldsOrder[id]\n\n  if (fieldIndex === undefined) {\n    throw new Error(`Field with id ${id} wasn't found in your form`)\n  }\n\n  const field = form.fields[fieldIndex]\n  return field\n}\n\nexport const useGoogleForm = ({ form }: { form: GoogleForm }) => {\n  const methods = useForm() as UseGoogleFormReturn\n\n  methods.getField = (id: string) => resolveField(id, form)\n\n  methods.submitToGoogleForms = (formData) =>\n    submitToGoogleForms(form, formData)\n\n  return methods\n}\n","import useCustomOptionField from './utils/useCustomOptionField'\nimport { UseCustomOptionField } from '../types'\n\nexport const useRadioInput = (id: string): UseCustomOptionField => {\n  return useCustomOptionField(id, 'RADIO')\n}\n","import useCustomOptionField from './utils/useCustomOptionField'\nimport { UseCustomOptionField } from '../types'\n\nexport const useCheckboxInput = (id: string): UseCustomOptionField => {\n  return useCustomOptionField(id, 'CHECKBOX')\n}\n","import { RegisterOptions } from 'react-hook-form'\n\nimport { UseTextFieldReturn, TextField } from '../../types'\nimport { useGoogleFormContext } from '../useGoogleFormContext'\nimport getFieldFromContext from './getFieldFromContext'\n\nexport default (\n  id: string,\n  fieldType: 'LONG_ANSWER' | 'SHORT_ANSWER'\n): UseTextFieldReturn => {\n  const context = useGoogleFormContext()\n\n  const field = getFieldFromContext(context, id, fieldType) as TextField\n\n  const error = context!.formState.errors[field.id]\n\n  const register = (options?: RegisterOptions) =>\n    context!.register(id, { required: field.required, ...options })\n\n  return { ...field, register, error }\n}\n","import useTextInput from './utils/useTextInput'\n\nexport const useShortAnswerInput = (id: string) => {\n  return useTextInput(id, 'SHORT_ANSWER')\n}\n","import useTextInput from './utils/useTextInput'\n\nexport const useLongAnswerInput = (id: string) => {\n  return useTextInput(id, 'LONG_ANSWER')\n}\n","import { useEffect, useState } from 'react'\nimport { RegisterOptions } from 'react-hook-form'\nimport slugify from 'slugify'\n\nimport { useGoogleFormContext } from '../useGoogleFormContext'\nimport getFieldFromContext from './getFieldFromContext'\nimport {\n  UseGridFieldReturn,\n  GridField,\n  RenderLineFunction,\n  RenderColumnFunction,\n  GridErrors\n} from '../../types'\n\nexport default (\n  id: string,\n  type: 'RADIO_GRID' | 'CHECKBOX_GRID'\n): UseGridFieldReturn => {\n  const context = useGoogleFormContext()\n  const [errors, setErrors] = useState<GridErrors | undefined>(undefined)\n\n  const field = getFieldFromContext(context, id, type) as GridField\n\n  const buildId = (lineId: string, value: string) => {\n    return `${id}-${lineId}-${slugify(value)}`\n  }\n\n  useEffect(() => {\n    const newErrors: GridErrors = field.lines.reduce((acc: GridErrors, l) => {\n      const fieldError = context!.formState.errors[l.id]\n      if (fieldError) {\n        acc[l.id] = fieldError\n      }\n      return acc\n    }, {})\n\n    if (Object.keys(newErrors).length > 0) {\n      setErrors(newErrors)\n    } else {\n      setErrors(undefined)\n    }\n  }, [context!.formState.errors])\n\n  const renderGrid = (render: RenderLineFunction): JSX.Element[] => {\n    return field.lines.map((l) => {\n      const registerLine = (options?: RegisterOptions) =>\n        context!.register(l.id, { required: field.required, ...options })\n\n      const renderColumns = (render: RenderColumnFunction): JSX.Element[] => {\n        return field.columns.map((c) => {\n          const id = buildId(l.id, c.label)\n          const registerColumn = (options?: RegisterOptions) => ({\n            ...registerLine(options),\n            value: c.label\n          })\n\n          return render({ ...c, registerColumn, id })\n        })\n      }\n\n      return render({ ...l, renderColumns })\n    })\n  }\n\n  return { ...field, renderGrid, errors }\n}\n","import useGridInput from './utils/useGridInput'\n\nexport const useCheckboxGridInput = (id: string) => {\n  return useGridInput(id, 'CHECKBOX_GRID')\n}\n","import useGridInput from './utils/useGridInput'\n\nexport const useRadioGridInput = (id: string) => {\n  return useGridInput(id, 'RADIO_GRID')\n}\n","import slugify from 'slugify'\n\nimport { useGoogleFormContext } from './useGoogleFormContext'\nimport getFieldFromContext from './utils/getFieldFromContext'\nimport { UseDropdownReturn, DropdownField } from '../types'\nimport { RegisterOptions } from 'react-hook-form'\n\nexport const useDropdownInput = (id: string): UseDropdownReturn => {\n  const context = useGoogleFormContext()\n\n  const field = getFieldFromContext(context, id, 'DROPDOWN') as DropdownField\n\n  const register = (options?: RegisterOptions) =>\n    context!.register(id, { required: field.required, ...options })\n\n  const error = context!.formState.errors[field.id]\n\n  const buildId = (value: string) => {\n    return `${field.id}-${slugify(value)}`\n  }\n\n  const options = field.options.map((o) => {\n    const id = buildId(o.label)\n    return {\n      ...o,\n      id\n    }\n  })\n\n  return { ...field, options, register, error }\n}\n","import slugify from 'slugify'\nimport { RegisterOptions } from 'react-hook-form'\n\nimport { useGoogleFormContext } from './useGoogleFormContext'\nimport getFieldFromContext from './utils/getFieldFromContext'\nimport { UseLinearInputReturn, LinearField } from '../types'\n\nexport const useLinearInput = (id: string): UseLinearInputReturn => {\n  const context = useGoogleFormContext()\n\n  const field = getFieldFromContext(context, id, 'LINEAR') as LinearField\n\n  const register = (options?: RegisterOptions) =>\n    context!.register(id, { required: field.required, ...options })\n\n  const buildId = (value: string) => {\n    return `${field.id}-${slugify(value)}`\n  }\n\n  const error = context!.formState.errors[field.id]\n\n  const options = field.options.map((o) => {\n    const id = buildId(o.label)\n    const registerOption = (options?: RegisterOptions) => ({\n      ...register(options),\n      value: o.label\n    })\n\n    return {\n      ...o,\n      id,\n      registerOption\n    }\n  })\n\n  return { ...field, options, error }\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import cheerio from 'cheerio'\nimport fetch from 'isomorphic-unfetch'\n\nimport {\n  Column,\n  CustomizableOption,\n  Field,\n  FieldsOrder,\n  GoogleForm,\n  Line,\n  Option\n} from '../types/form'\n\ntype FormData = {\n  formData: object\n  fbzx: string\n}\n\nconst toBool = (n: number): boolean => n === 1\n\nconst toString = (n: number): string => `${n}`\n\nconst assertValidUrl = (formUrl: string): void => {\n  const googleFormsHosts = ['docs.google.com', 'forms.gle']\n  const url = new URL(formUrl)\n\n  if (!googleFormsHosts.includes(url.host)) {\n    throw new Error(\n      `Invalid google forms host. ${\n        url.host\n      } is expected to be ${googleFormsHosts\n        .join(', ')\n        .replace(/, ([^,]*)$/, ' or $1')}.`\n    )\n  }\n\n  if (url.host === googleFormsHosts[0] && !url.pathname.endsWith('/viewform')) {\n    throw new Error(`Please use the form's public URL.`)\n  }\n}\n\nconst getFormHtml = async (formUrl: string) => {\n  const response = await fetch(formUrl)\n  const html = await response.text()\n  return html\n}\n\nconst extractFormData = (html: string): FormData => {\n  const $ = cheerio.load(html)\n  const fbzx = $('[name=\"fbzx\"]').attr('value')\n\n  if (!fbzx) {\n    throw new Error(`Invalid form. Couldn't find fbzx field.`)\n  }\n\n  const scriptStringIdentifier = 'var FB_PUBLIC_LOAD_DATA_ ='\n  let scriptHtml = $('script')\n    .filter((_, el) => {\n      return $(el).html()!.includes(scriptStringIdentifier)\n    })\n    .first()\n    .html()\n\n  if (!scriptHtml) {\n    throw new Error(`Invalid form. Couldn't find script tag.`)\n  }\n\n  scriptHtml = scriptHtml.slice(0, -1)\n  scriptHtml = scriptHtml.replace(scriptStringIdentifier, '')\n\n  const formDataRaw = JSON.parse(scriptHtml)\n\n  return { formData: formDataRaw, fbzx }\n}\n\nconst parseGridMultiSelect = (rawField: Array<object>): 1 | 0 => {\n  const firstLine = rawField[4][0]\n  const canSelectMultiple = firstLine[11][0]\n\n  return canSelectMultiple\n}\n\nconst parseFieldType = (rawField: Array<object>, fieldId: number) => {\n  const fieldTypes = [\n    'SHORT_ANSWER',\n    'LONG_ANSWER',\n    'RADIO',\n    'DROPDOWN',\n    'CHECKBOX',\n    'LINEAR'\n  ] as const\n\n  if (fieldId === 7) {\n    if (parseGridMultiSelect(rawField) === 1) {\n      return 'CHECKBOX_GRID'\n    } else {\n      return 'RADIO_GRID'\n    }\n  }\n  if (fieldId === 9) {\n    return 'DATE'\n  }\n\n  return fieldTypes[fieldId]\n}\n\nconst parseOptions = (options: Array<object>): Array<Option> => {\n  return options.map((rawOption) => ({ label: rawOption[0] }))\n}\n\nconst parseCustomizableOptions = (\n  options: Array<object>\n): Array<CustomizableOption> => {\n  return options.map((rawOption) => ({\n    label: rawOption[0],\n    custom: rawOption[4] === 1\n  }))\n}\n\nconst flattenArray = (array: Array<Array<string>>): Array<Option | Column> => {\n  return array.map((item) => ({ label: item[0] }))\n}\n\nconst parseLines = (lines: Array<any>): Array<Line> => {\n  return lines.map((rawLine) => {\n    const line = {} as Line\n    line.id = toString(rawLine[0])\n    line.label = rawLine[3][0]\n    return line\n  })\n}\n\nconst parseField = (rawField: Array<any>): Field => {\n  const field = {} as Field\n\n  field.label = rawField[1]\n  field.description = rawField[2]\n\n  const fieldId = rawField[3]\n  field.type = parseFieldType(rawField, fieldId)\n\n  switch (field.type) {\n    case 'SHORT_ANSWER':\n    case 'LONG_ANSWER': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      field.required = toBool(fieldInfo[2])\n      break\n    }\n    case 'CHECKBOX':\n    case 'RADIO': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      field.options = parseCustomizableOptions(fieldInfo[1])\n      field.required = toBool(fieldInfo[2])\n      break\n    }\n    case 'DROPDOWN': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      field.options = parseOptions(fieldInfo[1])\n      field.required = toBool(fieldInfo[2])\n      break\n    }\n    case 'LINEAR': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      const [labelFirst, labelLast] = fieldInfo[3]\n      field.legend = { labelFirst, labelLast }\n      field.options = flattenArray(fieldInfo[1])\n      field.required = toBool(fieldInfo[2])\n      break\n    }\n    case 'CHECKBOX_GRID':\n    case 'RADIO_GRID': {\n      field.id = toString(rawField[0])\n      field.columns = flattenArray(rawField[4][0][1])\n      field.lines = parseLines(rawField[4])\n      field.required = toBool(rawField[4][0][2])\n      break\n    }\n    case 'DATE': {\n      const fieldInfo = rawField[4][0]\n      field.id = toString(fieldInfo[0])\n      field.required = toBool(rawField[4][0][2])\n      break\n    }\n  }\n\n  return field\n}\n\nconst parseFields = (\n  rawFields: Array<any>\n): { fields: Array<Field>; fieldsOrder: FieldsOrder } => {\n  const fieldsOrder = {}\n\n  const fields = rawFields.map((rawField: Array<any>, i: number) => {\n    const field = parseField(rawField)\n    fieldsOrder[`${field.id}`] = i\n    return field\n  })\n\n  return { fields, fieldsOrder }\n}\n\nconst parseFormData = ({ formData, fbzx }: FormData): GoogleForm => {\n  const googleForm = {} as GoogleForm\n\n  googleForm.fvv = 1\n  googleForm.pageHistory = 0\n  googleForm.fbzx = fbzx\n  googleForm.action = formData[14]\n  googleForm.title = formData[1][8]\n  googleForm.description = formData[1][0]\n\n  const { fields, fieldsOrder } = parseFields(formData[1][1])\n  googleForm.fields = fields\n  googleForm.fieldsOrder = fieldsOrder\n\n  return googleForm\n}\n\nexport const googleFormsToJson = async (formUrl: string) => {\n  assertValidUrl(formUrl)\n\n  let html\n  try {\n    html = await getFormHtml(formUrl)\n  } catch (err) {\n    throw new Error(`Failed to fetch form. ${err}`)\n  }\n\n  const formData = extractFormData(html)\n  return parseFormData(formData)\n}\n"]},"metadata":{},"sourceType":"module"}