{"ast":null,"code":"import { isTag, hasChildren } from \"domhandler\";\n/**\n * Search a node and its children for nodes passing a test function.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param node Node to search. Will be included in the result set if it matches.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\n\nexport function filter(test, node, recurse = true, limit = Infinity) {\n  if (!Array.isArray(node)) node = [node];\n  return find(test, node, recurse, limit);\n}\n/**\n * Search an array of node and its children for nodes passing a test function.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\n\nexport function find(test, nodes, recurse, limit) {\n  const result = [];\n\n  for (const elem of nodes) {\n    if (test(elem)) {\n      result.push(elem);\n      if (--limit <= 0) break;\n    }\n\n    if (recurse && hasChildren(elem) && elem.children.length > 0) {\n      const children = find(test, elem.children, recurse, limit);\n      result.push(...children);\n      limit -= children.length;\n      if (limit <= 0) break;\n    }\n  }\n\n  return result;\n}\n/**\n * Finds the first element inside of an array that matches a test function.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns The first node in the array that passes `test`.\n * @deprecated Use `Array.prototype.find` directly.\n */\n\nexport function findOneChild(test, nodes) {\n  return nodes.find(test);\n}\n/**\n * Finds one element in a tree that passes a test.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @returns The first child node that passes `test`.\n */\n\nexport function findOne(test, nodes, recurse = true) {\n  let elem = null;\n\n  for (let i = 0; i < nodes.length && !elem; i++) {\n    const checked = nodes[i];\n\n    if (!isTag(checked)) {\n      continue;\n    } else if (test(checked)) {\n      elem = checked;\n    } else if (recurse && checked.children.length > 0) {\n      elem = findOne(test, checked.children, true);\n    }\n  }\n\n  return elem;\n}\n/**\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns Whether a tree of nodes contains at least one node passing the test.\n */\n\nexport function existsOne(test, nodes) {\n  return nodes.some(checked => isTag(checked) && (test(checked) || checked.children.length > 0 && existsOne(test, checked.children)));\n}\n/**\n * Search and array of nodes and its children for elements passing a test function.\n *\n * Same as `find`, but limited to elements and with less options, leading to reduced complexity.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns All nodes passing `test`.\n */\n\nexport function findAll(test, nodes) {\n  var _a;\n\n  const result = [];\n  const stack = nodes.filter(isTag);\n  let elem;\n\n  while (elem = stack.shift()) {\n    const children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(isTag);\n\n    if (children && children.length > 0) {\n      stack.unshift(...children);\n    }\n\n    if (test(elem)) result.push(elem);\n  }\n\n  return result;\n}","map":{"version":3,"sources":["querying.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/domutils/f7e357b5c210b6731c2a60e0b7b3cfaa1f96b706/src/","sourcesContent":["import { isTag, hasChildren } from \"domhandler\";\n/**\n * Search a node and its children for nodes passing a test function.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param node Node to search. Will be included in the result set if it matches.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nexport function filter(test, node, recurse = true, limit = Infinity) {\n    if (!Array.isArray(node))\n        node = [node];\n    return find(test, node, recurse, limit);\n}\n/**\n * Search an array of node and its children for nodes passing a test function.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nexport function find(test, nodes, recurse, limit) {\n    const result = [];\n    for (const elem of nodes) {\n        if (test(elem)) {\n            result.push(elem);\n            if (--limit <= 0)\n                break;\n        }\n        if (recurse && hasChildren(elem) && elem.children.length > 0) {\n            const children = find(test, elem.children, recurse, limit);\n            result.push(...children);\n            limit -= children.length;\n            if (limit <= 0)\n                break;\n        }\n    }\n    return result;\n}\n/**\n * Finds the first element inside of an array that matches a test function.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns The first node in the array that passes `test`.\n * @deprecated Use `Array.prototype.find` directly.\n */\nexport function findOneChild(test, nodes) {\n    return nodes.find(test);\n}\n/**\n * Finds one element in a tree that passes a test.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @returns The first child node that passes `test`.\n */\nexport function findOne(test, nodes, recurse = true) {\n    let elem = null;\n    for (let i = 0; i < nodes.length && !elem; i++) {\n        const checked = nodes[i];\n        if (!isTag(checked)) {\n            continue;\n        }\n        else if (test(checked)) {\n            elem = checked;\n        }\n        else if (recurse && checked.children.length > 0) {\n            elem = findOne(test, checked.children, true);\n        }\n    }\n    return elem;\n}\n/**\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns Whether a tree of nodes contains at least one node passing the test.\n */\nexport function existsOne(test, nodes) {\n    return nodes.some((checked) => isTag(checked) &&\n        (test(checked) ||\n            (checked.children.length > 0 &&\n                existsOne(test, checked.children))));\n}\n/**\n * Search and array of nodes and its children for elements passing a test function.\n *\n * Same as `find`, but limited to elements and with less options, leading to reduced complexity.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns All nodes passing `test`.\n */\nexport function findAll(test, nodes) {\n    var _a;\n    const result = [];\n    const stack = nodes.filter(isTag);\n    let elem;\n    while ((elem = stack.shift())) {\n        const children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(isTag);\n        if (children && children.length > 0) {\n            stack.unshift(...children);\n        }\n        if (test(elem))\n            result.push(elem);\n    }\n    return result;\n}\n//# sourceMappingURL=querying.js.map"]},"metadata":{},"sourceType":"module"}