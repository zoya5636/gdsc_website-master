{"ast":null,"code":"import * as DomUtils from \"domutils\";\nimport boolbase from \"boolbase\";\nimport { compile as compileRaw, compileUnsafe, compileToken } from \"./compile.js\";\nimport { getNextSiblings } from \"./pseudo-selectors/subselects.js\";\n\nconst defaultEquals = (a, b) => a === b;\n\nconst defaultOptions = {\n  adapter: DomUtils,\n  equals: defaultEquals\n};\n\nfunction convertOptionFormats(options) {\n  var _a, _b, _c, _d;\n  /*\n   * We force one format of options to the other one.\n   */\n  // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.\n\n\n  const opts = options !== null && options !== void 0 ? options : defaultOptions; // @ts-expect-error Same as above.\n\n  (_a = opts.adapter) !== null && _a !== void 0 ? _a : opts.adapter = DomUtils; // @ts-expect-error `equals` does not exist on `Options`\n\n  (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;\n  return opts;\n}\n\nfunction wrapCompile(func) {\n  return function addAdapter(selector, options, context) {\n    const opts = convertOptionFormats(options);\n    return func(selector, opts, context);\n  };\n}\n/**\n * Compiles the query, returns a function.\n */\n\n\nexport const compile = wrapCompile(compileRaw);\nexport const _compileUnsafe = wrapCompile(compileUnsafe);\nexport const _compileToken = wrapCompile(compileToken);\n\nfunction getSelectorFunc(searchFunc) {\n  return function select(query, elements, options) {\n    const opts = convertOptionFormats(options);\n\n    if (typeof query !== \"function\") {\n      query = compileUnsafe(query, opts, elements);\n    }\n\n    const filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);\n    return searchFunc(query, filteredElements, opts);\n  };\n}\n\nexport function prepareContext(elems, adapter, shouldTestNextSiblings = false) {\n  /*\n   * Add siblings if the query requires them.\n   * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692\n   */\n  if (shouldTestNextSiblings) {\n    elems = appendNextSiblings(elems, adapter);\n  }\n\n  return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);\n}\n\nfunction appendNextSiblings(elem, adapter) {\n  // Order matters because jQuery seems to check the children before the siblings\n  const elems = Array.isArray(elem) ? elem.slice(0) : [elem];\n  const elemsLength = elems.length;\n\n  for (let i = 0; i < elemsLength; i++) {\n    const nextSiblings = getNextSiblings(elems[i], adapter);\n    elems.push(...nextSiblings);\n  }\n\n  return elems;\n}\n/**\n * @template Node The generic Node type for the DOM adapter being used.\n * @template ElementNode The Node type for elements for the DOM adapter being used.\n * @param elems Elements to query. If it is an element, its children will be queried..\n * @param query can be either a CSS selector string or a compiled query function.\n * @param [options] options for querying the document.\n * @see compile for supported selector queries.\n * @returns All matching elements.\n *\n */\n\n\nexport const selectAll = getSelectorFunc((query, elems, options) => query === boolbase.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems));\n/**\n * @template Node The generic Node type for the DOM adapter being used.\n * @template ElementNode The Node type for elements for the DOM adapter being used.\n * @param elems Elements to query. If it is an element, its children will be queried..\n * @param query can be either a CSS selector string or a compiled query function.\n * @param [options] options for querying the document.\n * @see compile for supported selector queries.\n * @returns the first match, or null if there was no match.\n */\n\nexport const selectOne = getSelectorFunc((query, elems, options) => query === boolbase.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems));\n/**\n * Tests whether or not an element is matched by query.\n *\n * @template Node The generic Node type for the DOM adapter being used.\n * @template ElementNode The Node type for elements for the DOM adapter being used.\n * @param elem The element to test if it matches the query.\n * @param query can be either a CSS selector string or a compiled query function.\n * @param [options] options for querying the document.\n * @see compile for supported selector queries.\n * @returns\n */\n\nexport function is(elem, query, options) {\n  const opts = convertOptionFormats(options);\n  return (typeof query === \"function\" ? query : compileRaw(query, opts))(elem);\n}\n/**\n * Alias for selectAll(query, elems, options).\n * @see [compile] for supported selector queries.\n */\n\nexport default selectAll; // Export filters, pseudos and aliases to allow users to supply their own.\n\n/** @deprecated Use the `pseudos` option instead. */\n\nexport { filters, pseudos, aliases } from \"./pseudo-selectors/index.js\";","map":{"version":3,"sources":["index.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/css-select/0f0725a9dfeddd2fdb54eda9656cdbab5bbf6be6/src/","sourcesContent":["import * as DomUtils from \"domutils\";\nimport boolbase from \"boolbase\";\nimport { compile as compileRaw, compileUnsafe, compileToken, } from \"./compile.js\";\nimport { getNextSiblings } from \"./pseudo-selectors/subselects.js\";\nconst defaultEquals = (a, b) => a === b;\nconst defaultOptions = {\n    adapter: DomUtils,\n    equals: defaultEquals,\n};\nfunction convertOptionFormats(options) {\n    var _a, _b, _c, _d;\n    /*\n     * We force one format of options to the other one.\n     */\n    // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.\n    const opts = options !== null && options !== void 0 ? options : defaultOptions;\n    // @ts-expect-error Same as above.\n    (_a = opts.adapter) !== null && _a !== void 0 ? _a : (opts.adapter = DomUtils);\n    // @ts-expect-error `equals` does not exist on `Options`\n    (_b = opts.equals) !== null && _b !== void 0 ? _b : (opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals);\n    return opts;\n}\nfunction wrapCompile(func) {\n    return function addAdapter(selector, options, context) {\n        const opts = convertOptionFormats(options);\n        return func(selector, opts, context);\n    };\n}\n/**\n * Compiles the query, returns a function.\n */\nexport const compile = wrapCompile(compileRaw);\nexport const _compileUnsafe = wrapCompile(compileUnsafe);\nexport const _compileToken = wrapCompile(compileToken);\nfunction getSelectorFunc(searchFunc) {\n    return function select(query, elements, options) {\n        const opts = convertOptionFormats(options);\n        if (typeof query !== \"function\") {\n            query = compileUnsafe(query, opts, elements);\n        }\n        const filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);\n        return searchFunc(query, filteredElements, opts);\n    };\n}\nexport function prepareContext(elems, adapter, shouldTestNextSiblings = false) {\n    /*\n     * Add siblings if the query requires them.\n     * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692\n     */\n    if (shouldTestNextSiblings) {\n        elems = appendNextSiblings(elems, adapter);\n    }\n    return Array.isArray(elems)\n        ? adapter.removeSubsets(elems)\n        : adapter.getChildren(elems);\n}\nfunction appendNextSiblings(elem, adapter) {\n    // Order matters because jQuery seems to check the children before the siblings\n    const elems = Array.isArray(elem) ? elem.slice(0) : [elem];\n    const elemsLength = elems.length;\n    for (let i = 0; i < elemsLength; i++) {\n        const nextSiblings = getNextSiblings(elems[i], adapter);\n        elems.push(...nextSiblings);\n    }\n    return elems;\n}\n/**\n * @template Node The generic Node type for the DOM adapter being used.\n * @template ElementNode The Node type for elements for the DOM adapter being used.\n * @param elems Elements to query. If it is an element, its children will be queried..\n * @param query can be either a CSS selector string or a compiled query function.\n * @param [options] options for querying the document.\n * @see compile for supported selector queries.\n * @returns All matching elements.\n *\n */\nexport const selectAll = getSelectorFunc((query, elems, options) => query === boolbase.falseFunc || !elems || elems.length === 0\n    ? []\n    : options.adapter.findAll(query, elems));\n/**\n * @template Node The generic Node type for the DOM adapter being used.\n * @template ElementNode The Node type for elements for the DOM adapter being used.\n * @param elems Elements to query. If it is an element, its children will be queried..\n * @param query can be either a CSS selector string or a compiled query function.\n * @param [options] options for querying the document.\n * @see compile for supported selector queries.\n * @returns the first match, or null if there was no match.\n */\nexport const selectOne = getSelectorFunc((query, elems, options) => query === boolbase.falseFunc || !elems || elems.length === 0\n    ? null\n    : options.adapter.findOne(query, elems));\n/**\n * Tests whether or not an element is matched by query.\n *\n * @template Node The generic Node type for the DOM adapter being used.\n * @template ElementNode The Node type for elements for the DOM adapter being used.\n * @param elem The element to test if it matches the query.\n * @param query can be either a CSS selector string or a compiled query function.\n * @param [options] options for querying the document.\n * @see compile for supported selector queries.\n * @returns\n */\nexport function is(elem, query, options) {\n    const opts = convertOptionFormats(options);\n    return (typeof query === \"function\" ? query : compileRaw(query, opts))(elem);\n}\n/**\n * Alias for selectAll(query, elems, options).\n * @see [compile] for supported selector queries.\n */\nexport default selectAll;\n// Export filters, pseudos and aliases to allow users to supply their own.\n/** @deprecated Use the `pseudos` option instead. */\nexport { filters, pseudos, aliases } from \"./pseudo-selectors/index.js\";\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}