{"ast":null,"code":"import { removeElement } from 'domutils';\nimport { Document, isDocument as checkIsDocument } from 'domhandler';\n/**\n * Get the parse function with options.\n *\n * @param parser - The parser function.\n * @returns The parse function with options.\n */\n\nexport function getParse(parser) {\n  /**\n   * Parse a HTML string or a node.\n   *\n   * @param content - The HTML string or node.\n   * @param options - The parser options.\n   * @param isDocument - If `content` is a document.\n   * @param context - The context node in the DOM tree.\n   * @returns The parsed document node.\n   */\n  return function parse(content, options, isDocument, context) {\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(content)) {\n      content = content.toString();\n    }\n\n    if (typeof content === 'string') {\n      return parser(content, options, isDocument, context);\n    }\n\n    const doc = content;\n\n    if (!Array.isArray(doc) && checkIsDocument(doc)) {\n      // If `doc` is already a root, just return it\n      return doc;\n    } // Add conent to new root element\n\n\n    const root = new Document([]); // Update the DOM using the root\n\n    update(doc, root);\n    return root;\n  };\n}\n/**\n * Update the dom structure, for one changed layer.\n *\n * @param newChilds - The new children.\n * @param parent - The new parent.\n * @returns The parent node.\n */\n\nexport function update(newChilds, parent) {\n  // Normalize\n  const arr = Array.isArray(newChilds) ? newChilds : [newChilds]; // Update parent\n\n  if (parent) {\n    parent.children = arr;\n  } else {\n    parent = null;\n  } // Update neighbors\n\n\n  for (let i = 0; i < arr.length; i++) {\n    const node = arr[i]; // Cleanly remove existing nodes from their previous structures.\n\n    if (node.parent && node.parent.children !== arr) {\n      removeElement(node);\n    }\n\n    if (parent) {\n      node.prev = arr[i - 1] || null;\n      node.next = arr[i + 1] || null;\n    } else {\n      node.prev = node.next = null;\n    }\n\n    node.parent = parent;\n  }\n\n  return parent;\n}","map":{"version":3,"sources":["parse.ts"],"names":[],"mappings":"AAAA,SAAS,aAAT,QAA8B,UAA9B;AACA,SAEE,QAFF,EAIE,UAAU,IAAI,eAJhB,QAKO,YALP;AAQA;;;;;AAKG;;AACH,OAAM,SAAU,QAAV,CACJ,MADI,EAMS;AAEb;;;;;;;;AAQG;AACH,SAAO,SAAS,KAAT,CACL,OADK,EAEL,OAFK,EAGL,UAHK,EAIL,OAJK,EAIqB;AAE1B,QAAI,OAAO,MAAP,KAAkB,WAAlB,IAAiC,MAAM,CAAC,QAAP,CAAgB,OAAhB,CAArC,EAA+D;AAC7D,MAAA,OAAO,GAAG,OAAO,CAAC,QAAR,EAAV;AACD;;AAED,QAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,aAAO,MAAM,CAAC,OAAD,EAAU,OAAV,EAAmB,UAAnB,EAA+B,OAA/B,CAAb;AACD;;AAED,UAAM,GAAG,GAAG,OAAZ;;AAEA,QAAI,CAAC,KAAK,CAAC,OAAN,CAAc,GAAd,CAAD,IAAuB,eAAe,CAAC,GAAD,CAA1C,EAAiD;AAC/C;AACA,aAAO,GAAP;AACD,KAfyB,CAiB1B;;;AACA,UAAM,IAAI,GAAG,IAAI,QAAJ,CAAa,EAAb,CAAb,CAlB0B,CAoB1B;;AACA,IAAA,MAAM,CAAC,GAAD,EAAM,IAAN,CAAN;AAEA,WAAO,IAAP;AACD,GA5BD;AA6BD;AAED;;;;;;AAMG;;AACH,OAAM,SAAU,MAAV,CACJ,SADI,EAEJ,MAFI,EAEqB;AAEzB;AACA,QAAM,GAAG,GAAG,KAAK,CAAC,OAAN,CAAc,SAAd,IAA2B,SAA3B,GAAuC,CAAC,SAAD,CAAnD,CAHyB,CAKzB;;AACA,MAAI,MAAJ,EAAY;AACV,IAAA,MAAM,CAAC,QAAP,GAAkB,GAAlB;AACD,GAFD,MAEO;AACL,IAAA,MAAM,GAAG,IAAT;AACD,GAVwB,CAYzB;;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAAG,CAAC,MAAxB,EAAgC,CAAC,EAAjC,EAAqC;AACnC,UAAM,IAAI,GAAG,GAAG,CAAC,CAAD,CAAhB,CADmC,CAGnC;;AACA,QAAI,IAAI,CAAC,MAAL,IAAe,IAAI,CAAC,MAAL,CAAY,QAAZ,KAAyB,GAA5C,EAAiD;AAC/C,MAAA,aAAa,CAAC,IAAD,CAAb;AACD;;AAED,QAAI,MAAJ,EAAY;AACV,MAAA,IAAI,CAAC,IAAL,GAAY,GAAG,CAAC,CAAC,GAAG,CAAL,CAAH,IAAc,IAA1B;AACA,MAAA,IAAI,CAAC,IAAL,GAAY,GAAG,CAAC,CAAC,GAAG,CAAL,CAAH,IAAc,IAA1B;AACD,KAHD,MAGO;AACL,MAAA,IAAI,CAAC,IAAL,GAAY,IAAI,CAAC,IAAL,GAAY,IAAxB;AACD;;AAED,IAAA,IAAI,CAAC,MAAL,GAAc,MAAd;AACD;;AAED,SAAO,MAAP;AACD","sourceRoot":"https://raw.githubusercontent.com/cheeriojs/cheerio/d1cbc66d53392ce8bf6cd0068f675836372d2bf3/src/","sourcesContent":["import { removeElement } from 'domutils';\nimport { Document, isDocument as checkIsDocument, } from 'domhandler';\n/**\n * Get the parse function with options.\n *\n * @param parser - The parser function.\n * @returns The parse function with options.\n */\nexport function getParse(parser) {\n    /**\n     * Parse a HTML string or a node.\n     *\n     * @param content - The HTML string or node.\n     * @param options - The parser options.\n     * @param isDocument - If `content` is a document.\n     * @param context - The context node in the DOM tree.\n     * @returns The parsed document node.\n     */\n    return function parse(content, options, isDocument, context) {\n        if (typeof Buffer !== 'undefined' && Buffer.isBuffer(content)) {\n            content = content.toString();\n        }\n        if (typeof content === 'string') {\n            return parser(content, options, isDocument, context);\n        }\n        const doc = content;\n        if (!Array.isArray(doc) && checkIsDocument(doc)) {\n            // If `doc` is already a root, just return it\n            return doc;\n        }\n        // Add conent to new root element\n        const root = new Document([]);\n        // Update the DOM using the root\n        update(doc, root);\n        return root;\n    };\n}\n/**\n * Update the dom structure, for one changed layer.\n *\n * @param newChilds - The new children.\n * @param parent - The new parent.\n * @returns The parent node.\n */\nexport function update(newChilds, parent) {\n    // Normalize\n    const arr = Array.isArray(newChilds) ? newChilds : [newChilds];\n    // Update parent\n    if (parent) {\n        parent.children = arr;\n    }\n    else {\n        parent = null;\n    }\n    // Update neighbors\n    for (let i = 0; i < arr.length; i++) {\n        const node = arr[i];\n        // Cleanly remove existing nodes from their previous structures.\n        if (node.parent && node.parent.children !== arr) {\n            removeElement(node);\n        }\n        if (parent) {\n            node.prev = arr[i - 1] || null;\n            node.next = arr[i + 1] || null;\n        }\n        else {\n            node.prev = node.next = null;\n        }\n        node.parent = parent;\n    }\n    return parent;\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}