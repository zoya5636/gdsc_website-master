{"ast":null,"code":"import { ElementType, isTag as isTagRaw } from \"domelementtype\";\n/**\n * This object will be used as the prototype for Nodes when creating a\n * DOM-Level-1-compliant structure.\n */\n\nexport class Node {\n  constructor() {\n    /** Parent of the node */\n    this.parent = null;\n    /** Previous sibling */\n\n    this.prev = null;\n    /** Next sibling */\n\n    this.next = null;\n    /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */\n\n    this.startIndex = null;\n    /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */\n\n    this.endIndex = null;\n  } // Read-write aliases for properties\n\n  /**\n   * Same as {@link parent}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n\n\n  get parentNode() {\n    return this.parent;\n  }\n\n  set parentNode(parent) {\n    this.parent = parent;\n  }\n  /**\n   * Same as {@link prev}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n\n\n  get previousSibling() {\n    return this.prev;\n  }\n\n  set previousSibling(prev) {\n    this.prev = prev;\n  }\n  /**\n   * Same as {@link next}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n\n\n  get nextSibling() {\n    return this.next;\n  }\n\n  set nextSibling(next) {\n    this.next = next;\n  }\n  /**\n   * Clone this node, and optionally its children.\n   *\n   * @param recursive Clone child nodes as well.\n   * @returns A clone of the node.\n   */\n\n\n  cloneNode(recursive = false) {\n    return cloneNode(this, recursive);\n  }\n\n}\n/**\n * A node that contains some data.\n */\n\nexport class DataNode extends Node {\n  /**\n   * @param data The content of the data node\n   */\n  constructor(data) {\n    super();\n    this.data = data;\n  }\n  /**\n   * Same as {@link data}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n\n\n  get nodeValue() {\n    return this.data;\n  }\n\n  set nodeValue(data) {\n    this.data = data;\n  }\n\n}\n/**\n * Text within the document.\n */\n\nexport class Text extends DataNode {\n  constructor() {\n    super(...arguments);\n    this.type = ElementType.Text;\n  }\n\n  get nodeType() {\n    return 3;\n  }\n\n}\n/**\n * Comments within the document.\n */\n\nexport class Comment extends DataNode {\n  constructor() {\n    super(...arguments);\n    this.type = ElementType.Comment;\n  }\n\n  get nodeType() {\n    return 8;\n  }\n\n}\n/**\n * Processing instructions, including doc types.\n */\n\nexport class ProcessingInstruction extends DataNode {\n  constructor(name, data) {\n    super(data);\n    this.name = name;\n    this.type = ElementType.Directive;\n  }\n\n  get nodeType() {\n    return 1;\n  }\n\n}\n/**\n * A `Node` that can have children.\n */\n\nexport class NodeWithChildren extends Node {\n  /**\n   * @param children Children of the node. Only certain node types can have children.\n   */\n  constructor(children) {\n    super();\n    this.children = children;\n  } // Aliases\n\n  /** First child of the node. */\n\n\n  get firstChild() {\n    var _a;\n\n    return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;\n  }\n  /** Last child of the node. */\n\n\n  get lastChild() {\n    return this.children.length > 0 ? this.children[this.children.length - 1] : null;\n  }\n  /**\n   * Same as {@link children}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n\n\n  get childNodes() {\n    return this.children;\n  }\n\n  set childNodes(children) {\n    this.children = children;\n  }\n\n}\nexport class CDATA extends NodeWithChildren {\n  constructor() {\n    super(...arguments);\n    this.type = ElementType.CDATA;\n  }\n\n  get nodeType() {\n    return 4;\n  }\n\n}\n/**\n * The root node of the document.\n */\n\nexport class Document extends NodeWithChildren {\n  constructor() {\n    super(...arguments);\n    this.type = ElementType.Root;\n  }\n\n  get nodeType() {\n    return 9;\n  }\n\n}\n/**\n * An element within the DOM.\n */\n\nexport class Element extends NodeWithChildren {\n  /**\n   * @param name Name of the tag, eg. `div`, `span`.\n   * @param attribs Object mapping attribute names to attribute values.\n   * @param children Children of the node.\n   */\n  constructor(name, attribs, children = [], type = name === \"script\" ? ElementType.Script : name === \"style\" ? ElementType.Style : ElementType.Tag) {\n    super(children);\n    this.name = name;\n    this.attribs = attribs;\n    this.type = type;\n  }\n\n  get nodeType() {\n    return 1;\n  } // DOM Level 1 aliases\n\n  /**\n   * Same as {@link name}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n\n\n  get tagName() {\n    return this.name;\n  }\n\n  set tagName(name) {\n    this.name = name;\n  }\n\n  get attributes() {\n    return Object.keys(this.attribs).map(name => {\n      var _a, _b;\n\n      return {\n        name,\n        value: this.attribs[name],\n        namespace: (_a = this[\"x-attribsNamespace\"]) === null || _a === void 0 ? void 0 : _a[name],\n        prefix: (_b = this[\"x-attribsPrefix\"]) === null || _b === void 0 ? void 0 : _b[name]\n      };\n    });\n  }\n\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node is a `Element`, `false` otherwise.\n */\n\nexport function isTag(node) {\n  return isTagRaw(node);\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `CDATA`, `false` otherwise.\n */\n\nexport function isCDATA(node) {\n  return node.type === ElementType.CDATA;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Text`, `false` otherwise.\n */\n\nexport function isText(node) {\n  return node.type === ElementType.Text;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Comment`, `false` otherwise.\n */\n\nexport function isComment(node) {\n  return node.type === ElementType.Comment;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\n\nexport function isDirective(node) {\n  return node.type === ElementType.Directive;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\n\nexport function isDocument(node) {\n  return node.type === ElementType.Root;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has children, `false` otherwise.\n */\n\nexport function hasChildren(node) {\n  return Object.prototype.hasOwnProperty.call(node, \"children\");\n}\n/**\n * Clone a node, and optionally its children.\n *\n * @param recursive Clone child nodes as well.\n * @returns A clone of the node.\n */\n\nexport function cloneNode(node, recursive = false) {\n  let result;\n\n  if (isText(node)) {\n    result = new Text(node.data);\n  } else if (isComment(node)) {\n    result = new Comment(node.data);\n  } else if (isTag(node)) {\n    const children = recursive ? cloneChildren(node.children) : [];\n    const clone = new Element(node.name, { ...node.attribs\n    }, children);\n    children.forEach(child => child.parent = clone);\n\n    if (node.namespace != null) {\n      clone.namespace = node.namespace;\n    }\n\n    if (node[\"x-attribsNamespace\"]) {\n      clone[\"x-attribsNamespace\"] = { ...node[\"x-attribsNamespace\"]\n      };\n    }\n\n    if (node[\"x-attribsPrefix\"]) {\n      clone[\"x-attribsPrefix\"] = { ...node[\"x-attribsPrefix\"]\n      };\n    }\n\n    result = clone;\n  } else if (isCDATA(node)) {\n    const children = recursive ? cloneChildren(node.children) : [];\n    const clone = new CDATA(children);\n    children.forEach(child => child.parent = clone);\n    result = clone;\n  } else if (isDocument(node)) {\n    const children = recursive ? cloneChildren(node.children) : [];\n    const clone = new Document(children);\n    children.forEach(child => child.parent = clone);\n\n    if (node[\"x-mode\"]) {\n      clone[\"x-mode\"] = node[\"x-mode\"];\n    }\n\n    result = clone;\n  } else if (isDirective(node)) {\n    const instruction = new ProcessingInstruction(node.name, node.data);\n\n    if (node[\"x-name\"] != null) {\n      instruction[\"x-name\"] = node[\"x-name\"];\n      instruction[\"x-publicId\"] = node[\"x-publicId\"];\n      instruction[\"x-systemId\"] = node[\"x-systemId\"];\n    }\n\n    result = instruction;\n  } else {\n    throw new Error(`Not implemented yet: ${node.type}`);\n  }\n\n  result.startIndex = node.startIndex;\n  result.endIndex = node.endIndex;\n\n  if (node.sourceCodeLocation != null) {\n    result.sourceCodeLocation = node.sourceCodeLocation;\n  }\n\n  return result;\n}\n\nfunction cloneChildren(childs) {\n  const children = childs.map(child => cloneNode(child, true));\n\n  for (let i = 1; i < children.length; i++) {\n    children[i].prev = children[i - 1];\n    children[i - 1].next = children[i];\n  }\n\n  return children;\n}","map":{"version":3,"sources":["C:/Users/zoya/Downloads/gdsc_website-master/gdsc_website-master/node_modules/parse5-htmlparser2-tree-adapter/node_modules/domhandler/lib/esm/node.js"],"names":["ElementType","isTag","isTagRaw","Node","constructor","parent","prev","next","startIndex","endIndex","parentNode","previousSibling","nextSibling","cloneNode","recursive","DataNode","data","nodeValue","Text","arguments","type","nodeType","Comment","ProcessingInstruction","name","Directive","NodeWithChildren","children","firstChild","_a","lastChild","length","childNodes","CDATA","Document","Root","Element","attribs","Script","Style","Tag","tagName","attributes","Object","keys","map","_b","value","namespace","prefix","node","isCDATA","isText","isComment","isDirective","isDocument","hasChildren","prototype","hasOwnProperty","call","result","cloneChildren","clone","forEach","child","instruction","Error","sourceCodeLocation","childs","i"],"mappings":"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","sourcesContent":["import { ElementType, isTag as isTagRaw } from \"domelementtype\";\n/**\n * This object will be used as the prototype for Nodes when creating a\n * DOM-Level-1-compliant structure.\n */\nexport class Node {\n    constructor() {\n        /** Parent of the node */\n        this.parent = null;\n        /** Previous sibling */\n        this.prev = null;\n        /** Next sibling */\n        this.next = null;\n        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */\n        this.startIndex = null;\n        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */\n        this.endIndex = null;\n    }\n    // Read-write aliases for properties\n    /**\n     * Same as {@link parent}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get parentNode() {\n        return this.parent;\n    }\n    set parentNode(parent) {\n        this.parent = parent;\n    }\n    /**\n     * Same as {@link prev}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get previousSibling() {\n        return this.prev;\n    }\n    set previousSibling(prev) {\n        this.prev = prev;\n    }\n    /**\n     * Same as {@link next}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get nextSibling() {\n        return this.next;\n    }\n    set nextSibling(next) {\n        this.next = next;\n    }\n    /**\n     * Clone this node, and optionally its children.\n     *\n     * @param recursive Clone child nodes as well.\n     * @returns A clone of the node.\n     */\n    cloneNode(recursive = false) {\n        return cloneNode(this, recursive);\n    }\n}\n/**\n * A node that contains some data.\n */\nexport class DataNode extends Node {\n    /**\n     * @param data The content of the data node\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n    }\n    /**\n     * Same as {@link data}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get nodeValue() {\n        return this.data;\n    }\n    set nodeValue(data) {\n        this.data = data;\n    }\n}\n/**\n * Text within the document.\n */\nexport class Text extends DataNode {\n    constructor() {\n        super(...arguments);\n        this.type = ElementType.Text;\n    }\n    get nodeType() {\n        return 3;\n    }\n}\n/**\n * Comments within the document.\n */\nexport class Comment extends DataNode {\n    constructor() {\n        super(...arguments);\n        this.type = ElementType.Comment;\n    }\n    get nodeType() {\n        return 8;\n    }\n}\n/**\n * Processing instructions, including doc types.\n */\nexport class ProcessingInstruction extends DataNode {\n    constructor(name, data) {\n        super(data);\n        this.name = name;\n        this.type = ElementType.Directive;\n    }\n    get nodeType() {\n        return 1;\n    }\n}\n/**\n * A `Node` that can have children.\n */\nexport class NodeWithChildren extends Node {\n    /**\n     * @param children Children of the node. Only certain node types can have children.\n     */\n    constructor(children) {\n        super();\n        this.children = children;\n    }\n    // Aliases\n    /** First child of the node. */\n    get firstChild() {\n        var _a;\n        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;\n    }\n    /** Last child of the node. */\n    get lastChild() {\n        return this.children.length > 0\n            ? this.children[this.children.length - 1]\n            : null;\n    }\n    /**\n     * Same as {@link children}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get childNodes() {\n        return this.children;\n    }\n    set childNodes(children) {\n        this.children = children;\n    }\n}\nexport class CDATA extends NodeWithChildren {\n    constructor() {\n        super(...arguments);\n        this.type = ElementType.CDATA;\n    }\n    get nodeType() {\n        return 4;\n    }\n}\n/**\n * The root node of the document.\n */\nexport class Document extends NodeWithChildren {\n    constructor() {\n        super(...arguments);\n        this.type = ElementType.Root;\n    }\n    get nodeType() {\n        return 9;\n    }\n}\n/**\n * An element within the DOM.\n */\nexport class Element extends NodeWithChildren {\n    /**\n     * @param name Name of the tag, eg. `div`, `span`.\n     * @param attribs Object mapping attribute names to attribute values.\n     * @param children Children of the node.\n     */\n    constructor(name, attribs, children = [], type = name === \"script\"\n        ? ElementType.Script\n        : name === \"style\"\n            ? ElementType.Style\n            : ElementType.Tag) {\n        super(children);\n        this.name = name;\n        this.attribs = attribs;\n        this.type = type;\n    }\n    get nodeType() {\n        return 1;\n    }\n    // DOM Level 1 aliases\n    /**\n     * Same as {@link name}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get tagName() {\n        return this.name;\n    }\n    set tagName(name) {\n        this.name = name;\n    }\n    get attributes() {\n        return Object.keys(this.attribs).map((name) => {\n            var _a, _b;\n            return ({\n                name,\n                value: this.attribs[name],\n                namespace: (_a = this[\"x-attribsNamespace\"]) === null || _a === void 0 ? void 0 : _a[name],\n                prefix: (_b = this[\"x-attribsPrefix\"]) === null || _b === void 0 ? void 0 : _b[name],\n            });\n        });\n    }\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node is a `Element`, `false` otherwise.\n */\nexport function isTag(node) {\n    return isTagRaw(node);\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `CDATA`, `false` otherwise.\n */\nexport function isCDATA(node) {\n    return node.type === ElementType.CDATA;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Text`, `false` otherwise.\n */\nexport function isText(node) {\n    return node.type === ElementType.Text;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Comment`, `false` otherwise.\n */\nexport function isComment(node) {\n    return node.type === ElementType.Comment;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\nexport function isDirective(node) {\n    return node.type === ElementType.Directive;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\nexport function isDocument(node) {\n    return node.type === ElementType.Root;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has children, `false` otherwise.\n */\nexport function hasChildren(node) {\n    return Object.prototype.hasOwnProperty.call(node, \"children\");\n}\n/**\n * Clone a node, and optionally its children.\n *\n * @param recursive Clone child nodes as well.\n * @returns A clone of the node.\n */\nexport function cloneNode(node, recursive = false) {\n    let result;\n    if (isText(node)) {\n        result = new Text(node.data);\n    }\n    else if (isComment(node)) {\n        result = new Comment(node.data);\n    }\n    else if (isTag(node)) {\n        const children = recursive ? cloneChildren(node.children) : [];\n        const clone = new Element(node.name, { ...node.attribs }, children);\n        children.forEach((child) => (child.parent = clone));\n        if (node.namespace != null) {\n            clone.namespace = node.namespace;\n        }\n        if (node[\"x-attribsNamespace\"]) {\n            clone[\"x-attribsNamespace\"] = { ...node[\"x-attribsNamespace\"] };\n        }\n        if (node[\"x-attribsPrefix\"]) {\n            clone[\"x-attribsPrefix\"] = { ...node[\"x-attribsPrefix\"] };\n        }\n        result = clone;\n    }\n    else if (isCDATA(node)) {\n        const children = recursive ? cloneChildren(node.children) : [];\n        const clone = new CDATA(children);\n        children.forEach((child) => (child.parent = clone));\n        result = clone;\n    }\n    else if (isDocument(node)) {\n        const children = recursive ? cloneChildren(node.children) : [];\n        const clone = new Document(children);\n        children.forEach((child) => (child.parent = clone));\n        if (node[\"x-mode\"]) {\n            clone[\"x-mode\"] = node[\"x-mode\"];\n        }\n        result = clone;\n    }\n    else if (isDirective(node)) {\n        const instruction = new ProcessingInstruction(node.name, node.data);\n        if (node[\"x-name\"] != null) {\n            instruction[\"x-name\"] = node[\"x-name\"];\n            instruction[\"x-publicId\"] = node[\"x-publicId\"];\n            instruction[\"x-systemId\"] = node[\"x-systemId\"];\n        }\n        result = instruction;\n    }\n    else {\n        throw new Error(`Not implemented yet: ${node.type}`);\n    }\n    result.startIndex = node.startIndex;\n    result.endIndex = node.endIndex;\n    if (node.sourceCodeLocation != null) {\n        result.sourceCodeLocation = node.sourceCodeLocation;\n    }\n    return result;\n}\nfunction cloneChildren(childs) {\n    const children = childs.map((child) => cloneNode(child, true));\n    for (let i = 1; i < children.length; i++) {\n        children[i].prev = children[i - 1];\n        children[i - 1].next = children[i];\n    }\n    return children;\n}\n"]},"metadata":{},"sourceType":"module"}