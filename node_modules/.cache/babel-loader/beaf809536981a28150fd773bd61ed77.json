{"ast":null,"code":"// While filters are precompiled, pseudos get called when they are needed\nexport const pseudos = {\n  empty(elem, {\n    adapter\n  }) {\n    return !adapter.getChildren(elem).some(elem => // FIXME: `getText` call is potentially expensive.\n    adapter.isTag(elem) || adapter.getText(elem) !== \"\");\n  },\n\n  \"first-child\"(elem, {\n    adapter,\n    equals\n  }) {\n    if (adapter.prevElementSibling) {\n      return adapter.prevElementSibling(elem) == null;\n    }\n\n    const firstChild = adapter.getSiblings(elem).find(elem => adapter.isTag(elem));\n    return firstChild != null && equals(elem, firstChild);\n  },\n\n  \"last-child\"(elem, {\n    adapter,\n    equals\n  }) {\n    const siblings = adapter.getSiblings(elem);\n\n    for (let i = siblings.length - 1; i >= 0; i--) {\n      if (equals(elem, siblings[i])) return true;\n      if (adapter.isTag(siblings[i])) break;\n    }\n\n    return false;\n  },\n\n  \"first-of-type\"(elem, {\n    adapter,\n    equals\n  }) {\n    const siblings = adapter.getSiblings(elem);\n    const elemName = adapter.getName(elem);\n\n    for (let i = 0; i < siblings.length; i++) {\n      const currentSibling = siblings[i];\n      if (equals(elem, currentSibling)) return true;\n\n      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {\n        break;\n      }\n    }\n\n    return false;\n  },\n\n  \"last-of-type\"(elem, {\n    adapter,\n    equals\n  }) {\n    const siblings = adapter.getSiblings(elem);\n    const elemName = adapter.getName(elem);\n\n    for (let i = siblings.length - 1; i >= 0; i--) {\n      const currentSibling = siblings[i];\n      if (equals(elem, currentSibling)) return true;\n\n      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {\n        break;\n      }\n    }\n\n    return false;\n  },\n\n  \"only-of-type\"(elem, {\n    adapter,\n    equals\n  }) {\n    const elemName = adapter.getName(elem);\n    return adapter.getSiblings(elem).every(sibling => equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName);\n  },\n\n  \"only-child\"(elem, {\n    adapter,\n    equals\n  }) {\n    return adapter.getSiblings(elem).every(sibling => equals(elem, sibling) || !adapter.isTag(sibling));\n  }\n\n};\nexport function verifyPseudoArgs(func, name, subselect, argIndex) {\n  if (subselect === null) {\n    if (func.length > argIndex) {\n      throw new Error(`Pseudo-class :${name} requires an argument`);\n    }\n  } else if (func.length === argIndex) {\n    throw new Error(`Pseudo-class :${name} doesn't have any arguments`);\n  }\n}","map":{"version":3,"sources":["pseudo-selectors/pseudos.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/css-select/0f0725a9dfeddd2fdb54eda9656cdbab5bbf6be6/src/","sourcesContent":["// While filters are precompiled, pseudos get called when they are needed\nexport const pseudos = {\n    empty(elem, { adapter }) {\n        return !adapter.getChildren(elem).some((elem) => \n        // FIXME: `getText` call is potentially expensive.\n        adapter.isTag(elem) || adapter.getText(elem) !== \"\");\n    },\n    \"first-child\"(elem, { adapter, equals }) {\n        if (adapter.prevElementSibling) {\n            return adapter.prevElementSibling(elem) == null;\n        }\n        const firstChild = adapter\n            .getSiblings(elem)\n            .find((elem) => adapter.isTag(elem));\n        return firstChild != null && equals(elem, firstChild);\n    },\n    \"last-child\"(elem, { adapter, equals }) {\n        const siblings = adapter.getSiblings(elem);\n        for (let i = siblings.length - 1; i >= 0; i--) {\n            if (equals(elem, siblings[i]))\n                return true;\n            if (adapter.isTag(siblings[i]))\n                break;\n        }\n        return false;\n    },\n    \"first-of-type\"(elem, { adapter, equals }) {\n        const siblings = adapter.getSiblings(elem);\n        const elemName = adapter.getName(elem);\n        for (let i = 0; i < siblings.length; i++) {\n            const currentSibling = siblings[i];\n            if (equals(elem, currentSibling))\n                return true;\n            if (adapter.isTag(currentSibling) &&\n                adapter.getName(currentSibling) === elemName) {\n                break;\n            }\n        }\n        return false;\n    },\n    \"last-of-type\"(elem, { adapter, equals }) {\n        const siblings = adapter.getSiblings(elem);\n        const elemName = adapter.getName(elem);\n        for (let i = siblings.length - 1; i >= 0; i--) {\n            const currentSibling = siblings[i];\n            if (equals(elem, currentSibling))\n                return true;\n            if (adapter.isTag(currentSibling) &&\n                adapter.getName(currentSibling) === elemName) {\n                break;\n            }\n        }\n        return false;\n    },\n    \"only-of-type\"(elem, { adapter, equals }) {\n        const elemName = adapter.getName(elem);\n        return adapter\n            .getSiblings(elem)\n            .every((sibling) => equals(elem, sibling) ||\n            !adapter.isTag(sibling) ||\n            adapter.getName(sibling) !== elemName);\n    },\n    \"only-child\"(elem, { adapter, equals }) {\n        return adapter\n            .getSiblings(elem)\n            .every((sibling) => equals(elem, sibling) || !adapter.isTag(sibling));\n    },\n};\nexport function verifyPseudoArgs(func, name, subselect, argIndex) {\n    if (subselect === null) {\n        if (func.length > argIndex) {\n            throw new Error(`Pseudo-class :${name} requires an argument`);\n        }\n    }\n    else if (func.length === argIndex) {\n        throw new Error(`Pseudo-class :${name} doesn't have any arguments`);\n    }\n}\n//# sourceMappingURL=pseudos.js.map"]},"metadata":{},"sourceType":"module"}