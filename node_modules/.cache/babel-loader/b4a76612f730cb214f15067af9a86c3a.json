{"ast":null,"code":"import { parse, SelectorType } from \"css-what\";\nimport boolbase from \"boolbase\";\nimport sortRules, { isTraversal } from \"./sort.js\";\nimport { compileGeneralSelector } from \"./general.js\";\nimport { ensureIsTag, PLACEHOLDER_ELEMENT } from \"./pseudo-selectors/subselects.js\";\n/**\n * Compiles a selector to an executable function.\n *\n * @param selector Selector to compile.\n * @param options Compilation options.\n * @param context Optional context for the selector.\n */\n\nexport function compile(selector, options, context) {\n  const next = compileUnsafe(selector, options, context);\n  return ensureIsTag(next, options.adapter);\n}\nexport function compileUnsafe(selector, options, context) {\n  const token = typeof selector === \"string\" ? parse(selector) : selector;\n  return compileToken(token, options, context);\n}\n\nfunction includesScopePseudo(t) {\n  return t.type === SelectorType.Pseudo && (t.name === \"scope\" || Array.isArray(t.data) && t.data.some(data => data.some(includesScopePseudo)));\n}\n\nconst DESCENDANT_TOKEN = {\n  type: SelectorType.Descendant\n};\nconst FLEXIBLE_DESCENDANT_TOKEN = {\n  type: \"_flexibleDescendant\"\n};\nconst SCOPE_TOKEN = {\n  type: SelectorType.Pseudo,\n  name: \"scope\",\n  data: null\n};\n/*\n * CSS 4 Spec (Draft): 3.4.1. Absolutizing a Relative Selector\n * http://www.w3.org/TR/selectors4/#absolutizing\n */\n\nfunction absolutize(token, {\n  adapter\n}, context) {\n  // TODO Use better check if the context is a document\n  const hasContext = !!(context === null || context === void 0 ? void 0 : context.every(e => {\n    const parent = adapter.isTag(e) && adapter.getParent(e);\n    return e === PLACEHOLDER_ELEMENT || parent && adapter.isTag(parent);\n  }));\n\n  for (const t of token) {\n    if (t.length > 0 && isTraversal(t[0]) && t[0].type !== SelectorType.Descendant) {// Don't continue in else branch\n    } else if (hasContext && !t.some(includesScopePseudo)) {\n      t.unshift(DESCENDANT_TOKEN);\n    } else {\n      continue;\n    }\n\n    t.unshift(SCOPE_TOKEN);\n  }\n}\n\nexport function compileToken(token, options, context) {\n  var _a;\n\n  token.forEach(sortRules);\n  context = (_a = options.context) !== null && _a !== void 0 ? _a : context;\n  const isArrayContext = Array.isArray(context);\n  const finalContext = context && (Array.isArray(context) ? context : [context]); // Check if the selector is relative\n\n  if (options.relativeSelector !== false) {\n    absolutize(token, options, finalContext);\n  } else if (token.some(t => t.length > 0 && isTraversal(t[0]))) {\n    throw new Error(\"Relative selectors are not allowed when the `relativeSelector` option is disabled\");\n  }\n\n  let shouldTestNextSiblings = false;\n  const query = token.map(rules => {\n    if (rules.length >= 2) {\n      const [first, second] = rules;\n\n      if (first.type !== SelectorType.Pseudo || first.name !== \"scope\") {// Ignore\n      } else if (isArrayContext && second.type === SelectorType.Descendant) {\n        rules[1] = FLEXIBLE_DESCENDANT_TOKEN;\n      } else if (second.type === SelectorType.Adjacent || second.type === SelectorType.Sibling) {\n        shouldTestNextSiblings = true;\n      }\n    }\n\n    return compileRules(rules, options, finalContext);\n  }).reduce(reduceRules, boolbase.falseFunc);\n  query.shouldTestNextSiblings = shouldTestNextSiblings;\n  return query;\n}\n\nfunction compileRules(rules, options, context) {\n  var _a;\n\n  return rules.reduce((previous, rule) => previous === boolbase.falseFunc ? boolbase.falseFunc : compileGeneralSelector(previous, rule, options, context, compileToken), (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase.trueFunc);\n}\n\nfunction reduceRules(a, b) {\n  if (b === boolbase.falseFunc || a === boolbase.trueFunc) {\n    return a;\n  }\n\n  if (a === boolbase.falseFunc || b === boolbase.trueFunc) {\n    return b;\n  }\n\n  return function combine(elem) {\n    return a(elem) || b(elem);\n  };\n}","map":{"version":3,"sources":["compile.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/css-select/0f0725a9dfeddd2fdb54eda9656cdbab5bbf6be6/src/","sourcesContent":["import { parse, SelectorType } from \"css-what\";\nimport boolbase from \"boolbase\";\nimport sortRules, { isTraversal } from \"./sort.js\";\nimport { compileGeneralSelector } from \"./general.js\";\nimport { ensureIsTag, PLACEHOLDER_ELEMENT, } from \"./pseudo-selectors/subselects.js\";\n/**\n * Compiles a selector to an executable function.\n *\n * @param selector Selector to compile.\n * @param options Compilation options.\n * @param context Optional context for the selector.\n */\nexport function compile(selector, options, context) {\n    const next = compileUnsafe(selector, options, context);\n    return ensureIsTag(next, options.adapter);\n}\nexport function compileUnsafe(selector, options, context) {\n    const token = typeof selector === \"string\" ? parse(selector) : selector;\n    return compileToken(token, options, context);\n}\nfunction includesScopePseudo(t) {\n    return (t.type === SelectorType.Pseudo &&\n        (t.name === \"scope\" ||\n            (Array.isArray(t.data) &&\n                t.data.some((data) => data.some(includesScopePseudo)))));\n}\nconst DESCENDANT_TOKEN = { type: SelectorType.Descendant };\nconst FLEXIBLE_DESCENDANT_TOKEN = {\n    type: \"_flexibleDescendant\",\n};\nconst SCOPE_TOKEN = {\n    type: SelectorType.Pseudo,\n    name: \"scope\",\n    data: null,\n};\n/*\n * CSS 4 Spec (Draft): 3.4.1. Absolutizing a Relative Selector\n * http://www.w3.org/TR/selectors4/#absolutizing\n */\nfunction absolutize(token, { adapter }, context) {\n    // TODO Use better check if the context is a document\n    const hasContext = !!(context === null || context === void 0 ? void 0 : context.every((e) => {\n        const parent = adapter.isTag(e) && adapter.getParent(e);\n        return e === PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));\n    }));\n    for (const t of token) {\n        if (t.length > 0 &&\n            isTraversal(t[0]) &&\n            t[0].type !== SelectorType.Descendant) {\n            // Don't continue in else branch\n        }\n        else if (hasContext && !t.some(includesScopePseudo)) {\n            t.unshift(DESCENDANT_TOKEN);\n        }\n        else {\n            continue;\n        }\n        t.unshift(SCOPE_TOKEN);\n    }\n}\nexport function compileToken(token, options, context) {\n    var _a;\n    token.forEach(sortRules);\n    context = (_a = options.context) !== null && _a !== void 0 ? _a : context;\n    const isArrayContext = Array.isArray(context);\n    const finalContext = context && (Array.isArray(context) ? context : [context]);\n    // Check if the selector is relative\n    if (options.relativeSelector !== false) {\n        absolutize(token, options, finalContext);\n    }\n    else if (token.some((t) => t.length > 0 && isTraversal(t[0]))) {\n        throw new Error(\"Relative selectors are not allowed when the `relativeSelector` option is disabled\");\n    }\n    let shouldTestNextSiblings = false;\n    const query = token\n        .map((rules) => {\n        if (rules.length >= 2) {\n            const [first, second] = rules;\n            if (first.type !== SelectorType.Pseudo ||\n                first.name !== \"scope\") {\n                // Ignore\n            }\n            else if (isArrayContext &&\n                second.type === SelectorType.Descendant) {\n                rules[1] = FLEXIBLE_DESCENDANT_TOKEN;\n            }\n            else if (second.type === SelectorType.Adjacent ||\n                second.type === SelectorType.Sibling) {\n                shouldTestNextSiblings = true;\n            }\n        }\n        return compileRules(rules, options, finalContext);\n    })\n        .reduce(reduceRules, boolbase.falseFunc);\n    query.shouldTestNextSiblings = shouldTestNextSiblings;\n    return query;\n}\nfunction compileRules(rules, options, context) {\n    var _a;\n    return rules.reduce((previous, rule) => previous === boolbase.falseFunc\n        ? boolbase.falseFunc\n        : compileGeneralSelector(previous, rule, options, context, compileToken), (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase.trueFunc);\n}\nfunction reduceRules(a, b) {\n    if (b === boolbase.falseFunc || a === boolbase.trueFunc) {\n        return a;\n    }\n    if (a === boolbase.falseFunc || b === boolbase.trueFunc) {\n        return b;\n    }\n    return function combine(elem) {\n        return a(elem) || b(elem);\n    };\n}\n//# sourceMappingURL=compile.js.map"]},"metadata":{},"sourceType":"module"}