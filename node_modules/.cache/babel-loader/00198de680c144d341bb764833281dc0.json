{"ast":null,"code":"import { AttributeAction, SelectorType } from \"css-what\";\nconst procedure = new Map([[SelectorType.Universal, 50], [SelectorType.Tag, 30], [SelectorType.Attribute, 1], [SelectorType.Pseudo, 0]]);\nexport function isTraversal(token) {\n  return !procedure.has(token.type);\n}\nconst attributes = new Map([[AttributeAction.Exists, 10], [AttributeAction.Equals, 8], [AttributeAction.Not, 7], [AttributeAction.Start, 6], [AttributeAction.End, 6], [AttributeAction.Any, 5]]);\n/**\n * Sort the parts of the passed selector,\n * as there is potential for optimization\n * (some types of selectors are faster than others)\n *\n * @param arr Selector to sort\n */\n\nexport default function sortByProcedure(arr) {\n  const procs = arr.map(getProcedure);\n\n  for (let i = 1; i < arr.length; i++) {\n    const procNew = procs[i];\n    if (procNew < 0) continue;\n\n    for (let j = i - 1; j >= 0 && procNew < procs[j]; j--) {\n      const token = arr[j + 1];\n      arr[j + 1] = arr[j];\n      arr[j] = token;\n      procs[j + 1] = procs[j];\n      procs[j] = procNew;\n    }\n  }\n}\n\nfunction getProcedure(token) {\n  var _a, _b;\n\n  let proc = (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;\n\n  if (token.type === SelectorType.Attribute) {\n    proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;\n\n    if (token.action === AttributeAction.Equals && token.name === \"id\") {\n      // Prefer ID selectors (eg. #ID)\n      proc = 9;\n    }\n\n    if (token.ignoreCase) {\n      /*\n       * IgnoreCase adds some overhead, prefer \"normal\" token\n       * this is a binary operation, to ensure it's still an int\n       */\n      proc >>= 1;\n    }\n  } else if (token.type === SelectorType.Pseudo) {\n    if (!token.data) {\n      proc = 3;\n    } else if (token.name === \"has\" || token.name === \"contains\") {\n      proc = 0; // Expensive in any case\n    } else if (Array.isArray(token.data)) {\n      // Eg. :matches, :not\n      proc = Math.min(...token.data.map(d => Math.min(...d.map(getProcedure)))); // If we have traversals, try to avoid executing this selector\n\n      if (proc < 0) {\n        proc = 0;\n      }\n    } else {\n      proc = 2;\n    }\n  }\n\n  return proc;\n}","map":{"version":3,"sources":["sort.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/css-select/0f0725a9dfeddd2fdb54eda9656cdbab5bbf6be6/src/","sourcesContent":["import { AttributeAction, SelectorType } from \"css-what\";\nconst procedure = new Map([\n    [SelectorType.Universal, 50],\n    [SelectorType.Tag, 30],\n    [SelectorType.Attribute, 1],\n    [SelectorType.Pseudo, 0],\n]);\nexport function isTraversal(token) {\n    return !procedure.has(token.type);\n}\nconst attributes = new Map([\n    [AttributeAction.Exists, 10],\n    [AttributeAction.Equals, 8],\n    [AttributeAction.Not, 7],\n    [AttributeAction.Start, 6],\n    [AttributeAction.End, 6],\n    [AttributeAction.Any, 5],\n]);\n/**\n * Sort the parts of the passed selector,\n * as there is potential for optimization\n * (some types of selectors are faster than others)\n *\n * @param arr Selector to sort\n */\nexport default function sortByProcedure(arr) {\n    const procs = arr.map(getProcedure);\n    for (let i = 1; i < arr.length; i++) {\n        const procNew = procs[i];\n        if (procNew < 0)\n            continue;\n        for (let j = i - 1; j >= 0 && procNew < procs[j]; j--) {\n            const token = arr[j + 1];\n            arr[j + 1] = arr[j];\n            arr[j] = token;\n            procs[j + 1] = procs[j];\n            procs[j] = procNew;\n        }\n    }\n}\nfunction getProcedure(token) {\n    var _a, _b;\n    let proc = (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;\n    if (token.type === SelectorType.Attribute) {\n        proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;\n        if (token.action === AttributeAction.Equals && token.name === \"id\") {\n            // Prefer ID selectors (eg. #ID)\n            proc = 9;\n        }\n        if (token.ignoreCase) {\n            /*\n             * IgnoreCase adds some overhead, prefer \"normal\" token\n             * this is a binary operation, to ensure it's still an int\n             */\n            proc >>= 1;\n        }\n    }\n    else if (token.type === SelectorType.Pseudo) {\n        if (!token.data) {\n            proc = 3;\n        }\n        else if (token.name === \"has\" || token.name === \"contains\") {\n            proc = 0; // Expensive in any case\n        }\n        else if (Array.isArray(token.data)) {\n            // Eg. :matches, :not\n            proc = Math.min(...token.data.map((d) => Math.min(...d.map(getProcedure))));\n            // If we have traversals, try to avoid executing this selector\n            if (proc < 0) {\n                proc = 0;\n            }\n        }\n        else {\n            proc = 2;\n        }\n    }\n    return proc;\n}\n//# sourceMappingURL=sort.js.map"]},"metadata":{},"sourceType":"module"}