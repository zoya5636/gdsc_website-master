{"ast":null,"code":"export const xmlReplacer = /[\"&'<>$\\x80-\\uFFFF]/g;\nconst xmlCodeMap = new Map([[34, \"&quot;\"], [38, \"&amp;\"], [39, \"&apos;\"], [60, \"&lt;\"], [62, \"&gt;\"]]); // For compatibility with node < 4, we wrap `codePointAt`\n\nexport const getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n(c, index) => (c.charCodeAt(index) & 0xfc00) === 0xd800 ? (c.charCodeAt(index) - 0xd800) * 0x400 + c.charCodeAt(index + 1) - 0xdc00 + 0x10000 : c.charCodeAt(index);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\n\nexport function encodeXML(str) {\n  let ret = \"\";\n  let lastIdx = 0;\n  let match;\n\n  while ((match = xmlReplacer.exec(str)) !== null) {\n    const i = match.index;\n    const char = str.charCodeAt(i);\n    const next = xmlCodeMap.get(char);\n\n    if (next !== undefined) {\n      ret += str.substring(lastIdx, i) + next;\n      lastIdx = i + 1;\n    } else {\n      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`; // Increase by 1 if we have a surrogate pair\n\n      lastIdx = xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);\n    }\n  }\n\n  return ret + str.substr(lastIdx);\n}\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\n\nexport const escape = encodeXML;\n\nfunction getEscaper(regex, map) {\n  return function escape(data) {\n    let match;\n    let lastIdx = 0;\n    let result = \"\";\n\n    while (match = regex.exec(data)) {\n      if (lastIdx !== match.index) {\n        result += data.substring(lastIdx, match.index);\n      } // We know that this chararcter will be in the map.\n\n\n      result += map.get(match[0].charCodeAt(0)); // Every match will be of length 1\n\n      lastIdx = match.index + 1;\n    }\n\n    return result + data.substring(lastIdx);\n  };\n}\n/**\n * Encodes all characters not valid in XML documents using XML entities.\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\n\n\nexport const escapeUTF8 = getEscaper(/[&<>'\"]/g, xmlCodeMap);\n/**\n * Encodes all characters that have to be escaped in HTML attributes,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\n\nexport const escapeAttribute = getEscaper(/[\"&\\u00A0]/g, new Map([[34, \"&quot;\"], [38, \"&amp;\"], [160, \"&nbsp;\"]]));\n/**\n * Encodes all characters that have to be escaped in HTML text,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\n\nexport const escapeText = getEscaper(/[&<>\\u00A0]/g, new Map([[38, \"&amp;\"], [60, \"&lt;\"], [62, \"&gt;\"], [160, \"&nbsp;\"]]));","map":{"version":3,"sources":["escape.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/entities/867ac709ba482a56a98b7c35f49ca833c74dc193/src/","sourcesContent":["export const xmlReplacer = /[\"&'<>$\\x80-\\uFFFF]/g;\nconst xmlCodeMap = new Map([\n    [34, \"&quot;\"],\n    [38, \"&amp;\"],\n    [39, \"&apos;\"],\n    [60, \"&lt;\"],\n    [62, \"&gt;\"],\n]);\n// For compatibility with node < 4, we wrap `codePointAt`\nexport const getCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null\n    ? (str, index) => str.codePointAt(index)\n    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        (c, index) => (c.charCodeAt(index) & 0xfc00) === 0xd800\n            ? (c.charCodeAt(index) - 0xd800) * 0x400 +\n                c.charCodeAt(index + 1) -\n                0xdc00 +\n                0x10000\n            : c.charCodeAt(index);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nexport function encodeXML(str) {\n    let ret = \"\";\n    let lastIdx = 0;\n    let match;\n    while ((match = xmlReplacer.exec(str)) !== null) {\n        const i = match.index;\n        const char = str.charCodeAt(i);\n        const next = xmlCodeMap.get(char);\n        if (next !== undefined) {\n            ret += str.substring(lastIdx, i) + next;\n            lastIdx = i + 1;\n        }\n        else {\n            ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;\n            // Increase by 1 if we have a surrogate pair\n            lastIdx = xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);\n        }\n    }\n    return ret + str.substr(lastIdx);\n}\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nexport const escape = encodeXML;\nfunction getEscaper(regex, map) {\n    return function escape(data) {\n        let match;\n        let lastIdx = 0;\n        let result = \"\";\n        while ((match = regex.exec(data))) {\n            if (lastIdx !== match.index) {\n                result += data.substring(lastIdx, match.index);\n            }\n            // We know that this chararcter will be in the map.\n            result += map.get(match[0].charCodeAt(0));\n            // Every match will be of length 1\n            lastIdx = match.index + 1;\n        }\n        return result + data.substring(lastIdx);\n    };\n}\n/**\n * Encodes all characters not valid in XML documents using XML entities.\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nexport const escapeUTF8 = getEscaper(/[&<>'\"]/g, xmlCodeMap);\n/**\n * Encodes all characters that have to be escaped in HTML attributes,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\nexport const escapeAttribute = getEscaper(/[\"&\\u00A0]/g, new Map([\n    [34, \"&quot;\"],\n    [38, \"&amp;\"],\n    [160, \"&nbsp;\"],\n]));\n/**\n * Encodes all characters that have to be escaped in HTML text,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\nexport const escapeText = getEscaper(/[&<>\\u00A0]/g, new Map([\n    [38, \"&amp;\"],\n    [60, \"&lt;\"],\n    [62, \"&gt;\"],\n    [160, \"&nbsp;\"],\n]));\n//# sourceMappingURL=escape.js.map"]},"metadata":{},"sourceType":"module"}