{"ast":null,"code":"import getNCheck from \"nth-check\";\nimport boolbase from \"boolbase\";\n\nfunction getChildFunc(next, adapter) {\n  return elem => {\n    const parent = adapter.getParent(elem);\n    return parent != null && adapter.isTag(parent) && next(elem);\n  };\n}\n\nexport const filters = {\n  contains(next, text, {\n    adapter\n  }) {\n    return function contains(elem) {\n      return next(elem) && adapter.getText(elem).includes(text);\n    };\n  },\n\n  icontains(next, text, {\n    adapter\n  }) {\n    const itext = text.toLowerCase();\n    return function icontains(elem) {\n      return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);\n    };\n  },\n\n  // Location specific methods\n  \"nth-child\"(next, rule, {\n    adapter,\n    equals\n  }) {\n    const func = getNCheck(rule);\n    if (func === boolbase.falseFunc) return boolbase.falseFunc;\n    if (func === boolbase.trueFunc) return getChildFunc(next, adapter);\n    return function nthChild(elem) {\n      const siblings = adapter.getSiblings(elem);\n      let pos = 0;\n\n      for (let i = 0; i < siblings.length; i++) {\n        if (equals(elem, siblings[i])) break;\n\n        if (adapter.isTag(siblings[i])) {\n          pos++;\n        }\n      }\n\n      return func(pos) && next(elem);\n    };\n  },\n\n  \"nth-last-child\"(next, rule, {\n    adapter,\n    equals\n  }) {\n    const func = getNCheck(rule);\n    if (func === boolbase.falseFunc) return boolbase.falseFunc;\n    if (func === boolbase.trueFunc) return getChildFunc(next, adapter);\n    return function nthLastChild(elem) {\n      const siblings = adapter.getSiblings(elem);\n      let pos = 0;\n\n      for (let i = siblings.length - 1; i >= 0; i--) {\n        if (equals(elem, siblings[i])) break;\n\n        if (adapter.isTag(siblings[i])) {\n          pos++;\n        }\n      }\n\n      return func(pos) && next(elem);\n    };\n  },\n\n  \"nth-of-type\"(next, rule, {\n    adapter,\n    equals\n  }) {\n    const func = getNCheck(rule);\n    if (func === boolbase.falseFunc) return boolbase.falseFunc;\n    if (func === boolbase.trueFunc) return getChildFunc(next, adapter);\n    return function nthOfType(elem) {\n      const siblings = adapter.getSiblings(elem);\n      let pos = 0;\n\n      for (let i = 0; i < siblings.length; i++) {\n        const currentSibling = siblings[i];\n        if (equals(elem, currentSibling)) break;\n\n        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {\n          pos++;\n        }\n      }\n\n      return func(pos) && next(elem);\n    };\n  },\n\n  \"nth-last-of-type\"(next, rule, {\n    adapter,\n    equals\n  }) {\n    const func = getNCheck(rule);\n    if (func === boolbase.falseFunc) return boolbase.falseFunc;\n    if (func === boolbase.trueFunc) return getChildFunc(next, adapter);\n    return function nthLastOfType(elem) {\n      const siblings = adapter.getSiblings(elem);\n      let pos = 0;\n\n      for (let i = siblings.length - 1; i >= 0; i--) {\n        const currentSibling = siblings[i];\n        if (equals(elem, currentSibling)) break;\n\n        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {\n          pos++;\n        }\n      }\n\n      return func(pos) && next(elem);\n    };\n  },\n\n  // TODO determine the actual root element\n  root(next, _rule, {\n    adapter\n  }) {\n    return elem => {\n      const parent = adapter.getParent(elem);\n      return (parent == null || !adapter.isTag(parent)) && next(elem);\n    };\n  },\n\n  scope(next, rule, options, context) {\n    const {\n      equals\n    } = options;\n\n    if (!context || context.length === 0) {\n      // Equivalent to :root\n      return filters[\"root\"](next, rule, options);\n    }\n\n    if (context.length === 1) {\n      // NOTE: can't be unpacked, as :has uses this for side-effects\n      return elem => equals(context[0], elem) && next(elem);\n    }\n\n    return elem => context.includes(elem) && next(elem);\n  },\n\n  hover: dynamicStatePseudo(\"isHovered\"),\n  visited: dynamicStatePseudo(\"isVisited\"),\n  active: dynamicStatePseudo(\"isActive\")\n};\n/**\n * Dynamic state pseudos. These depend on optional Adapter methods.\n *\n * @param name The name of the adapter method to call.\n * @returns Pseudo for the `filters` object.\n */\n\nfunction dynamicStatePseudo(name) {\n  return function dynamicPseudo(next, _rule, {\n    adapter\n  }) {\n    const func = adapter[name];\n\n    if (typeof func !== \"function\") {\n      return boolbase.falseFunc;\n    }\n\n    return function active(elem) {\n      return func(elem) && next(elem);\n    };\n  };\n}","map":{"version":3,"sources":["pseudo-selectors/filters.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/css-select/0f0725a9dfeddd2fdb54eda9656cdbab5bbf6be6/src/","sourcesContent":["import getNCheck from \"nth-check\";\nimport boolbase from \"boolbase\";\nfunction getChildFunc(next, adapter) {\n    return (elem) => {\n        const parent = adapter.getParent(elem);\n        return parent != null && adapter.isTag(parent) && next(elem);\n    };\n}\nexport const filters = {\n    contains(next, text, { adapter }) {\n        return function contains(elem) {\n            return next(elem) && adapter.getText(elem).includes(text);\n        };\n    },\n    icontains(next, text, { adapter }) {\n        const itext = text.toLowerCase();\n        return function icontains(elem) {\n            return (next(elem) &&\n                adapter.getText(elem).toLowerCase().includes(itext));\n        };\n    },\n    // Location specific methods\n    \"nth-child\"(next, rule, { adapter, equals }) {\n        const func = getNCheck(rule);\n        if (func === boolbase.falseFunc)\n            return boolbase.falseFunc;\n        if (func === boolbase.trueFunc)\n            return getChildFunc(next, adapter);\n        return function nthChild(elem) {\n            const siblings = adapter.getSiblings(elem);\n            let pos = 0;\n            for (let i = 0; i < siblings.length; i++) {\n                if (equals(elem, siblings[i]))\n                    break;\n                if (adapter.isTag(siblings[i])) {\n                    pos++;\n                }\n            }\n            return func(pos) && next(elem);\n        };\n    },\n    \"nth-last-child\"(next, rule, { adapter, equals }) {\n        const func = getNCheck(rule);\n        if (func === boolbase.falseFunc)\n            return boolbase.falseFunc;\n        if (func === boolbase.trueFunc)\n            return getChildFunc(next, adapter);\n        return function nthLastChild(elem) {\n            const siblings = adapter.getSiblings(elem);\n            let pos = 0;\n            for (let i = siblings.length - 1; i >= 0; i--) {\n                if (equals(elem, siblings[i]))\n                    break;\n                if (adapter.isTag(siblings[i])) {\n                    pos++;\n                }\n            }\n            return func(pos) && next(elem);\n        };\n    },\n    \"nth-of-type\"(next, rule, { adapter, equals }) {\n        const func = getNCheck(rule);\n        if (func === boolbase.falseFunc)\n            return boolbase.falseFunc;\n        if (func === boolbase.trueFunc)\n            return getChildFunc(next, adapter);\n        return function nthOfType(elem) {\n            const siblings = adapter.getSiblings(elem);\n            let pos = 0;\n            for (let i = 0; i < siblings.length; i++) {\n                const currentSibling = siblings[i];\n                if (equals(elem, currentSibling))\n                    break;\n                if (adapter.isTag(currentSibling) &&\n                    adapter.getName(currentSibling) === adapter.getName(elem)) {\n                    pos++;\n                }\n            }\n            return func(pos) && next(elem);\n        };\n    },\n    \"nth-last-of-type\"(next, rule, { adapter, equals }) {\n        const func = getNCheck(rule);\n        if (func === boolbase.falseFunc)\n            return boolbase.falseFunc;\n        if (func === boolbase.trueFunc)\n            return getChildFunc(next, adapter);\n        return function nthLastOfType(elem) {\n            const siblings = adapter.getSiblings(elem);\n            let pos = 0;\n            for (let i = siblings.length - 1; i >= 0; i--) {\n                const currentSibling = siblings[i];\n                if (equals(elem, currentSibling))\n                    break;\n                if (adapter.isTag(currentSibling) &&\n                    adapter.getName(currentSibling) === adapter.getName(elem)) {\n                    pos++;\n                }\n            }\n            return func(pos) && next(elem);\n        };\n    },\n    // TODO determine the actual root element\n    root(next, _rule, { adapter }) {\n        return (elem) => {\n            const parent = adapter.getParent(elem);\n            return (parent == null || !adapter.isTag(parent)) && next(elem);\n        };\n    },\n    scope(next, rule, options, context) {\n        const { equals } = options;\n        if (!context || context.length === 0) {\n            // Equivalent to :root\n            return filters[\"root\"](next, rule, options);\n        }\n        if (context.length === 1) {\n            // NOTE: can't be unpacked, as :has uses this for side-effects\n            return (elem) => equals(context[0], elem) && next(elem);\n        }\n        return (elem) => context.includes(elem) && next(elem);\n    },\n    hover: dynamicStatePseudo(\"isHovered\"),\n    visited: dynamicStatePseudo(\"isVisited\"),\n    active: dynamicStatePseudo(\"isActive\"),\n};\n/**\n * Dynamic state pseudos. These depend on optional Adapter methods.\n *\n * @param name The name of the adapter method to call.\n * @returns Pseudo for the `filters` object.\n */\nfunction dynamicStatePseudo(name) {\n    return function dynamicPseudo(next, _rule, { adapter }) {\n        const func = adapter[name];\n        if (typeof func !== \"function\") {\n            return boolbase.falseFunc;\n        }\n        return function active(elem) {\n            return func(elem) && next(elem);\n        };\n    };\n}\n//# sourceMappingURL=filters.js.map"]},"metadata":{},"sourceType":"module"}