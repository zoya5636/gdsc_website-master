{"ast":null,"code":"import { hasChildren } from \"domhandler\";\n/**\n * Given an array of nodes, remove any member that is contained by another.\n *\n * @category Helpers\n * @param nodes Nodes to filter.\n * @returns Remaining nodes that aren't subtrees of each other.\n */\n\nexport function removeSubsets(nodes) {\n  let idx = nodes.length;\n  /*\n   * Check if each node (or one of its ancestors) is already contained in the\n   * array.\n   */\n\n  while (--idx >= 0) {\n    const node = nodes[idx];\n    /*\n     * Remove the node if it is not unique.\n     * We are going through the array from the end, so we only\n     * have to check nodes that preceed the node under consideration in the array.\n     */\n\n    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {\n      nodes.splice(idx, 1);\n      continue;\n    }\n\n    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n      if (nodes.includes(ancestor)) {\n        nodes.splice(idx, 1);\n        break;\n      }\n    }\n  }\n\n  return nodes;\n}\n/**\n * @category Helpers\n * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}\n */\n\nexport var DocumentPosition;\n\n(function (DocumentPosition) {\n  DocumentPosition[DocumentPosition[\"DISCONNECTED\"] = 1] = \"DISCONNECTED\";\n  DocumentPosition[DocumentPosition[\"PRECEDING\"] = 2] = \"PRECEDING\";\n  DocumentPosition[DocumentPosition[\"FOLLOWING\"] = 4] = \"FOLLOWING\";\n  DocumentPosition[DocumentPosition[\"CONTAINS\"] = 8] = \"CONTAINS\";\n  DocumentPosition[DocumentPosition[\"CONTAINED_BY\"] = 16] = \"CONTAINED_BY\";\n})(DocumentPosition || (DocumentPosition = {}));\n/**\n * Compare the position of one node against another node in any other document.\n * The return value is a bitmask with the values from {@link DocumentPosition}.\n *\n * Document order:\n * > There is an ordering, document order, defined on all the nodes in the\n * > document corresponding to the order in which the first character of the\n * > XML representation of each node occurs in the XML representation of the\n * > document after expansion of general entities. Thus, the document element\n * > node will be the first node. Element nodes occur before their children.\n * > Thus, document order orders element nodes in order of the occurrence of\n * > their start-tag in the XML (after expansion of entities). The attribute\n * > nodes of an element occur after the element and before its children. The\n * > relative order of attribute nodes is implementation-dependent.\n *\n * Source:\n * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n *\n * @category Helpers\n * @param nodeA The first node to use in the comparison\n * @param nodeB The second node to use in the comparison\n * @returns A bitmask describing the input nodes' relative position.\n *\n * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n * a description of these values.\n */\n\n\nexport function compareDocumentPosition(nodeA, nodeB) {\n  const aParents = [];\n  const bParents = [];\n\n  if (nodeA === nodeB) {\n    return 0;\n  }\n\n  let current = hasChildren(nodeA) ? nodeA : nodeA.parent;\n\n  while (current) {\n    aParents.unshift(current);\n    current = current.parent;\n  }\n\n  current = hasChildren(nodeB) ? nodeB : nodeB.parent;\n\n  while (current) {\n    bParents.unshift(current);\n    current = current.parent;\n  }\n\n  const maxIdx = Math.min(aParents.length, bParents.length);\n  let idx = 0;\n\n  while (idx < maxIdx && aParents[idx] === bParents[idx]) {\n    idx++;\n  }\n\n  if (idx === 0) {\n    return DocumentPosition.DISCONNECTED;\n  }\n\n  const sharedParent = aParents[idx - 1];\n  const siblings = sharedParent.children;\n  const aSibling = aParents[idx];\n  const bSibling = bParents[idx];\n\n  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n    if (sharedParent === nodeB) {\n      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;\n    }\n\n    return DocumentPosition.FOLLOWING;\n  }\n\n  if (sharedParent === nodeA) {\n    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;\n  }\n\n  return DocumentPosition.PRECEDING;\n}\n/**\n * Sort an array of nodes based on their relative position in the document and\n * remove any duplicate nodes. If the array contains nodes that do not belong to\n * the same document, sort order is unspecified.\n *\n * @category Helpers\n * @param nodes Array of DOM nodes.\n * @returns Collection of unique nodes, sorted in document order.\n */\n\nexport function uniqueSort(nodes) {\n  nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));\n  nodes.sort((a, b) => {\n    const relative = compareDocumentPosition(a, b);\n\n    if (relative & DocumentPosition.PRECEDING) {\n      return -1;\n    } else if (relative & DocumentPosition.FOLLOWING) {\n      return 1;\n    }\n\n    return 0;\n  });\n  return nodes;\n}","map":{"version":3,"sources":["helpers.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/domutils/f7e357b5c210b6731c2a60e0b7b3cfaa1f96b706/src/","sourcesContent":["import { hasChildren } from \"domhandler\";\n/**\n * Given an array of nodes, remove any member that is contained by another.\n *\n * @category Helpers\n * @param nodes Nodes to filter.\n * @returns Remaining nodes that aren't subtrees of each other.\n */\nexport function removeSubsets(nodes) {\n    let idx = nodes.length;\n    /*\n     * Check if each node (or one of its ancestors) is already contained in the\n     * array.\n     */\n    while (--idx >= 0) {\n        const node = nodes[idx];\n        /*\n         * Remove the node if it is not unique.\n         * We are going through the array from the end, so we only\n         * have to check nodes that preceed the node under consideration in the array.\n         */\n        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {\n            nodes.splice(idx, 1);\n            continue;\n        }\n        for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n            if (nodes.includes(ancestor)) {\n                nodes.splice(idx, 1);\n                break;\n            }\n        }\n    }\n    return nodes;\n}\n/**\n * @category Helpers\n * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}\n */\nexport var DocumentPosition;\n(function (DocumentPosition) {\n    DocumentPosition[DocumentPosition[\"DISCONNECTED\"] = 1] = \"DISCONNECTED\";\n    DocumentPosition[DocumentPosition[\"PRECEDING\"] = 2] = \"PRECEDING\";\n    DocumentPosition[DocumentPosition[\"FOLLOWING\"] = 4] = \"FOLLOWING\";\n    DocumentPosition[DocumentPosition[\"CONTAINS\"] = 8] = \"CONTAINS\";\n    DocumentPosition[DocumentPosition[\"CONTAINED_BY\"] = 16] = \"CONTAINED_BY\";\n})(DocumentPosition || (DocumentPosition = {}));\n/**\n * Compare the position of one node against another node in any other document.\n * The return value is a bitmask with the values from {@link DocumentPosition}.\n *\n * Document order:\n * > There is an ordering, document order, defined on all the nodes in the\n * > document corresponding to the order in which the first character of the\n * > XML representation of each node occurs in the XML representation of the\n * > document after expansion of general entities. Thus, the document element\n * > node will be the first node. Element nodes occur before their children.\n * > Thus, document order orders element nodes in order of the occurrence of\n * > their start-tag in the XML (after expansion of entities). The attribute\n * > nodes of an element occur after the element and before its children. The\n * > relative order of attribute nodes is implementation-dependent.\n *\n * Source:\n * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n *\n * @category Helpers\n * @param nodeA The first node to use in the comparison\n * @param nodeB The second node to use in the comparison\n * @returns A bitmask describing the input nodes' relative position.\n *\n * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n * a description of these values.\n */\nexport function compareDocumentPosition(nodeA, nodeB) {\n    const aParents = [];\n    const bParents = [];\n    if (nodeA === nodeB) {\n        return 0;\n    }\n    let current = hasChildren(nodeA) ? nodeA : nodeA.parent;\n    while (current) {\n        aParents.unshift(current);\n        current = current.parent;\n    }\n    current = hasChildren(nodeB) ? nodeB : nodeB.parent;\n    while (current) {\n        bParents.unshift(current);\n        current = current.parent;\n    }\n    const maxIdx = Math.min(aParents.length, bParents.length);\n    let idx = 0;\n    while (idx < maxIdx && aParents[idx] === bParents[idx]) {\n        idx++;\n    }\n    if (idx === 0) {\n        return DocumentPosition.DISCONNECTED;\n    }\n    const sharedParent = aParents[idx - 1];\n    const siblings = sharedParent.children;\n    const aSibling = aParents[idx];\n    const bSibling = bParents[idx];\n    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n        if (sharedParent === nodeB) {\n            return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;\n        }\n        return DocumentPosition.FOLLOWING;\n    }\n    if (sharedParent === nodeA) {\n        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;\n    }\n    return DocumentPosition.PRECEDING;\n}\n/**\n * Sort an array of nodes based on their relative position in the document and\n * remove any duplicate nodes. If the array contains nodes that do not belong to\n * the same document, sort order is unspecified.\n *\n * @category Helpers\n * @param nodes Array of DOM nodes.\n * @returns Collection of unique nodes, sorted in document order.\n */\nexport function uniqueSort(nodes) {\n    nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));\n    nodes.sort((a, b) => {\n        const relative = compareDocumentPosition(a, b);\n        if (relative & DocumentPosition.PRECEDING) {\n            return -1;\n        }\n        else if (relative & DocumentPosition.FOLLOWING) {\n            return 1;\n        }\n        return 0;\n    });\n    return nodes;\n}\n//# sourceMappingURL=helpers.js.map"]},"metadata":{},"sourceType":"module"}