{"ast":null,"code":"import { attributeRules } from \"./attributes.js\";\nimport { compilePseudoSelector } from \"./pseudo-selectors/index.js\";\nimport { SelectorType } from \"css-what\";\n\nfunction getElementParent(node, adapter) {\n  const parent = adapter.getParent(node);\n\n  if (parent && adapter.isTag(parent)) {\n    return parent;\n  }\n\n  return null;\n}\n/*\n * All available rules\n */\n\n\nexport function compileGeneralSelector(next, selector, options, context, compileToken) {\n  const {\n    adapter,\n    equals\n  } = options;\n\n  switch (selector.type) {\n    case SelectorType.PseudoElement:\n      {\n        throw new Error(\"Pseudo-elements are not supported by css-select\");\n      }\n\n    case SelectorType.ColumnCombinator:\n      {\n        throw new Error(\"Column combinators are not yet supported by css-select\");\n      }\n\n    case SelectorType.Attribute:\n      {\n        if (selector.namespace != null) {\n          throw new Error(\"Namespaced attributes are not yet supported by css-select\");\n        }\n\n        if (!options.xmlMode || options.lowerCaseAttributeNames) {\n          selector.name = selector.name.toLowerCase();\n        }\n\n        return attributeRules[selector.action](next, selector, options);\n      }\n\n    case SelectorType.Pseudo:\n      {\n        return compilePseudoSelector(next, selector, options, context, compileToken);\n      }\n    // Tags\n\n    case SelectorType.Tag:\n      {\n        if (selector.namespace != null) {\n          throw new Error(\"Namespaced tag names are not yet supported by css-select\");\n        }\n\n        let {\n          name\n        } = selector;\n\n        if (!options.xmlMode || options.lowerCaseTags) {\n          name = name.toLowerCase();\n        }\n\n        return function tag(elem) {\n          return adapter.getName(elem) === name && next(elem);\n        };\n      }\n    // Traversal\n\n    case SelectorType.Descendant:\n      {\n        if (options.cacheResults === false || typeof WeakSet === \"undefined\") {\n          return function descendant(elem) {\n            let current = elem;\n\n            while (current = getElementParent(current, adapter)) {\n              if (next(current)) {\n                return true;\n              }\n            }\n\n            return false;\n          };\n        } // @ts-expect-error `ElementNode` is not extending object\n\n\n        const isFalseCache = new WeakSet();\n        return function cachedDescendant(elem) {\n          let current = elem;\n\n          while (current = getElementParent(current, adapter)) {\n            if (!isFalseCache.has(current)) {\n              if (adapter.isTag(current) && next(current)) {\n                return true;\n              }\n\n              isFalseCache.add(current);\n            }\n          }\n\n          return false;\n        };\n      }\n\n    case \"_flexibleDescendant\":\n      {\n        // Include element itself, only used while querying an array\n        return function flexibleDescendant(elem) {\n          let current = elem;\n\n          do {\n            if (next(current)) return true;\n          } while (current = getElementParent(current, adapter));\n\n          return false;\n        };\n      }\n\n    case SelectorType.Parent:\n      {\n        return function parent(elem) {\n          return adapter.getChildren(elem).some(elem => adapter.isTag(elem) && next(elem));\n        };\n      }\n\n    case SelectorType.Child:\n      {\n        return function child(elem) {\n          const parent = adapter.getParent(elem);\n          return parent != null && adapter.isTag(parent) && next(parent);\n        };\n      }\n\n    case SelectorType.Sibling:\n      {\n        return function sibling(elem) {\n          const siblings = adapter.getSiblings(elem);\n\n          for (let i = 0; i < siblings.length; i++) {\n            const currentSibling = siblings[i];\n            if (equals(elem, currentSibling)) break;\n\n            if (adapter.isTag(currentSibling) && next(currentSibling)) {\n              return true;\n            }\n          }\n\n          return false;\n        };\n      }\n\n    case SelectorType.Adjacent:\n      {\n        if (adapter.prevElementSibling) {\n          return function adjacent(elem) {\n            const previous = adapter.prevElementSibling(elem);\n            return previous != null && next(previous);\n          };\n        }\n\n        return function adjacent(elem) {\n          const siblings = adapter.getSiblings(elem);\n          let lastElement;\n\n          for (let i = 0; i < siblings.length; i++) {\n            const currentSibling = siblings[i];\n            if (equals(elem, currentSibling)) break;\n\n            if (adapter.isTag(currentSibling)) {\n              lastElement = currentSibling;\n            }\n          }\n\n          return !!lastElement && next(lastElement);\n        };\n      }\n\n    case SelectorType.Universal:\n      {\n        if (selector.namespace != null && selector.namespace !== \"*\") {\n          throw new Error(\"Namespaced universal selectors are not yet supported by css-select\");\n        }\n\n        return next;\n      }\n  }\n}","map":{"version":3,"sources":["general.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/css-select/0f0725a9dfeddd2fdb54eda9656cdbab5bbf6be6/src/","sourcesContent":["import { attributeRules } from \"./attributes.js\";\nimport { compilePseudoSelector } from \"./pseudo-selectors/index.js\";\nimport { SelectorType } from \"css-what\";\nfunction getElementParent(node, adapter) {\n    const parent = adapter.getParent(node);\n    if (parent && adapter.isTag(parent)) {\n        return parent;\n    }\n    return null;\n}\n/*\n * All available rules\n */\nexport function compileGeneralSelector(next, selector, options, context, compileToken) {\n    const { adapter, equals } = options;\n    switch (selector.type) {\n        case SelectorType.PseudoElement: {\n            throw new Error(\"Pseudo-elements are not supported by css-select\");\n        }\n        case SelectorType.ColumnCombinator: {\n            throw new Error(\"Column combinators are not yet supported by css-select\");\n        }\n        case SelectorType.Attribute: {\n            if (selector.namespace != null) {\n                throw new Error(\"Namespaced attributes are not yet supported by css-select\");\n            }\n            if (!options.xmlMode || options.lowerCaseAttributeNames) {\n                selector.name = selector.name.toLowerCase();\n            }\n            return attributeRules[selector.action](next, selector, options);\n        }\n        case SelectorType.Pseudo: {\n            return compilePseudoSelector(next, selector, options, context, compileToken);\n        }\n        // Tags\n        case SelectorType.Tag: {\n            if (selector.namespace != null) {\n                throw new Error(\"Namespaced tag names are not yet supported by css-select\");\n            }\n            let { name } = selector;\n            if (!options.xmlMode || options.lowerCaseTags) {\n                name = name.toLowerCase();\n            }\n            return function tag(elem) {\n                return adapter.getName(elem) === name && next(elem);\n            };\n        }\n        // Traversal\n        case SelectorType.Descendant: {\n            if (options.cacheResults === false ||\n                typeof WeakSet === \"undefined\") {\n                return function descendant(elem) {\n                    let current = elem;\n                    while ((current = getElementParent(current, adapter))) {\n                        if (next(current)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n            }\n            // @ts-expect-error `ElementNode` is not extending object\n            const isFalseCache = new WeakSet();\n            return function cachedDescendant(elem) {\n                let current = elem;\n                while ((current = getElementParent(current, adapter))) {\n                    if (!isFalseCache.has(current)) {\n                        if (adapter.isTag(current) && next(current)) {\n                            return true;\n                        }\n                        isFalseCache.add(current);\n                    }\n                }\n                return false;\n            };\n        }\n        case \"_flexibleDescendant\": {\n            // Include element itself, only used while querying an array\n            return function flexibleDescendant(elem) {\n                let current = elem;\n                do {\n                    if (next(current))\n                        return true;\n                } while ((current = getElementParent(current, adapter)));\n                return false;\n            };\n        }\n        case SelectorType.Parent: {\n            return function parent(elem) {\n                return adapter\n                    .getChildren(elem)\n                    .some((elem) => adapter.isTag(elem) && next(elem));\n            };\n        }\n        case SelectorType.Child: {\n            return function child(elem) {\n                const parent = adapter.getParent(elem);\n                return parent != null && adapter.isTag(parent) && next(parent);\n            };\n        }\n        case SelectorType.Sibling: {\n            return function sibling(elem) {\n                const siblings = adapter.getSiblings(elem);\n                for (let i = 0; i < siblings.length; i++) {\n                    const currentSibling = siblings[i];\n                    if (equals(elem, currentSibling))\n                        break;\n                    if (adapter.isTag(currentSibling) && next(currentSibling)) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n        }\n        case SelectorType.Adjacent: {\n            if (adapter.prevElementSibling) {\n                return function adjacent(elem) {\n                    const previous = adapter.prevElementSibling(elem);\n                    return previous != null && next(previous);\n                };\n            }\n            return function adjacent(elem) {\n                const siblings = adapter.getSiblings(elem);\n                let lastElement;\n                for (let i = 0; i < siblings.length; i++) {\n                    const currentSibling = siblings[i];\n                    if (equals(elem, currentSibling))\n                        break;\n                    if (adapter.isTag(currentSibling)) {\n                        lastElement = currentSibling;\n                    }\n                }\n                return !!lastElement && next(lastElement);\n            };\n        }\n        case SelectorType.Universal: {\n            if (selector.namespace != null && selector.namespace !== \"*\") {\n                throw new Error(\"Namespaced universal selectors are not yet supported by css-select\");\n            }\n            return next;\n        }\n    }\n}\n//# sourceMappingURL=general.js.map"]},"metadata":{},"sourceType":"module"}