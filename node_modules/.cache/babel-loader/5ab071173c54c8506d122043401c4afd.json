{"ast":null,"code":"import { parse } from \"css-what\";\nimport { filters } from \"./filters.js\";\nimport { pseudos, verifyPseudoArgs } from \"./pseudos.js\";\nimport { aliases } from \"./aliases.js\";\nimport { subselects } from \"./subselects.js\";\nexport { filters, pseudos, aliases };\nexport function compilePseudoSelector(next, selector, options, context, compileToken) {\n  var _a;\n\n  const {\n    name,\n    data\n  } = selector;\n\n  if (Array.isArray(data)) {\n    if (!(name in subselects)) {\n      throw new Error(`Unknown pseudo-class :${name}(${data})`);\n    }\n\n    return subselects[name](next, data, options, context, compileToken);\n  }\n\n  const userPseudo = (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];\n  const stringPseudo = typeof userPseudo === \"string\" ? userPseudo : aliases[name];\n\n  if (typeof stringPseudo === \"string\") {\n    if (data != null) {\n      throw new Error(`Pseudo ${name} doesn't have any arguments`);\n    } // The alias has to be parsed here, to make sure options are respected.\n\n\n    const alias = parse(stringPseudo);\n    return subselects[\"is\"](next, alias, options, context, compileToken);\n  }\n\n  if (typeof userPseudo === \"function\") {\n    verifyPseudoArgs(userPseudo, name, data, 1);\n    return elem => userPseudo(elem, data) && next(elem);\n  }\n\n  if (name in filters) {\n    return filters[name](next, data, options, context);\n  }\n\n  if (name in pseudos) {\n    const pseudo = pseudos[name];\n    verifyPseudoArgs(pseudo, name, data, 2);\n    return elem => pseudo(elem, options, data) && next(elem);\n  }\n\n  throw new Error(`Unknown pseudo-class :${name}`);\n}","map":{"version":3,"sources":["pseudo-selectors/index.ts"],"names":[],"mappings":"AAeA,SAAS,KAAT,QAAsC,UAAtC;AACA,SAAS,OAAT,QAAwB,cAAxB;AACA,SAAS,OAAT,EAAkB,gBAAlB,QAA0C,cAA1C;AACA,SAAS,OAAT,QAAwB,cAAxB;AACA,SAAS,UAAT,QAA2B,iBAA3B;AAEA,SAAS,OAAT,EAAkB,OAAlB,EAA2B,OAA3B;AAEA,OAAM,SAAU,qBAAV,CACF,IADE,EAEF,QAFE,EAGF,OAHE,EAIF,OAJE,EAKF,YALE,EAK2C;;;AAE7C,QAAM;AAAE,IAAA,IAAF;AAAQ,IAAA;AAAR,MAAiB,QAAvB;;AAEA,MAAI,KAAK,CAAC,OAAN,CAAc,IAAd,CAAJ,EAAyB;AACrB,QAAI,EAAE,IAAI,IAAI,UAAV,CAAJ,EAA2B;AACvB,YAAM,IAAI,KAAJ,CAAU,yBAAyB,IAAI,IAAI,IAAI,GAA/C,CAAN;AACH;;AAED,WAAO,UAAU,CAAC,IAAD,CAAV,CAAiB,IAAjB,EAAuB,IAAvB,EAA6B,OAA7B,EAAsC,OAAtC,EAA+C,YAA/C,CAAP;AACH;;AAED,QAAM,UAAU,GAAG,CAAA,EAAA,GAAA,OAAO,CAAC,OAAR,MAAe,IAAf,IAAe,EAAA,KAAA,KAAA,CAAf,GAAe,KAAA,CAAf,GAAe,EAAA,CAAG,IAAH,CAAlC;AAEA,QAAM,YAAY,GACd,OAAO,UAAP,KAAsB,QAAtB,GAAiC,UAAjC,GAA8C,OAAO,CAAC,IAAD,CADzD;;AAGA,MAAI,OAAO,YAAP,KAAwB,QAA5B,EAAsC;AAClC,QAAI,IAAI,IAAI,IAAZ,EAAkB;AACd,YAAM,IAAI,KAAJ,CAAU,UAAU,IAAI,6BAAxB,CAAN;AACH,KAHiC,CAKlC;;;AACA,UAAM,KAAK,GAAG,KAAK,CAAC,YAAD,CAAnB;AACA,WAAO,UAAU,CAAC,IAAD,CAAV,CAAiB,IAAjB,EAAuB,KAAvB,EAA8B,OAA9B,EAAuC,OAAvC,EAAgD,YAAhD,CAAP;AACH;;AAED,MAAI,OAAO,UAAP,KAAsB,UAA1B,EAAsC;AAClC,IAAA,gBAAgB,CAAC,UAAD,EAAa,IAAb,EAAmB,IAAnB,EAAyB,CAAzB,CAAhB;AAEA,WAAQ,IAAD,IAAU,UAAU,CAAC,IAAD,EAAO,IAAP,CAAV,IAA0B,IAAI,CAAC,IAAD,CAA/C;AACH;;AAED,MAAI,IAAI,IAAI,OAAZ,EAAqB;AACjB,WAAO,OAAO,CAAC,IAAD,CAAP,CAAc,IAAd,EAAoB,IAApB,EAAoC,OAApC,EAA6C,OAA7C,CAAP;AACH;;AAED,MAAI,IAAI,IAAI,OAAZ,EAAqB;AACjB,UAAM,MAAM,GAAG,OAAO,CAAC,IAAD,CAAtB;AACA,IAAA,gBAAgB,CAAC,MAAD,EAAS,IAAT,EAAe,IAAf,EAAqB,CAArB,CAAhB;AAEA,WAAQ,IAAD,IAAU,MAAM,CAAC,IAAD,EAAO,OAAP,EAAgB,IAAhB,CAAN,IAA+B,IAAI,CAAC,IAAD,CAApD;AACH;;AAED,QAAM,IAAI,KAAJ,CAAU,yBAAyB,IAAI,EAAvC,CAAN;AACH","sourceRoot":"https://raw.githubusercontent.com/fb55/css-select/0f0725a9dfeddd2fdb54eda9656cdbab5bbf6be6/src/","sourcesContent":["import { parse } from \"css-what\";\nimport { filters } from \"./filters.js\";\nimport { pseudos, verifyPseudoArgs } from \"./pseudos.js\";\nimport { aliases } from \"./aliases.js\";\nimport { subselects } from \"./subselects.js\";\nexport { filters, pseudos, aliases };\nexport function compilePseudoSelector(next, selector, options, context, compileToken) {\n    var _a;\n    const { name, data } = selector;\n    if (Array.isArray(data)) {\n        if (!(name in subselects)) {\n            throw new Error(`Unknown pseudo-class :${name}(${data})`);\n        }\n        return subselects[name](next, data, options, context, compileToken);\n    }\n    const userPseudo = (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];\n    const stringPseudo = typeof userPseudo === \"string\" ? userPseudo : aliases[name];\n    if (typeof stringPseudo === \"string\") {\n        if (data != null) {\n            throw new Error(`Pseudo ${name} doesn't have any arguments`);\n        }\n        // The alias has to be parsed here, to make sure options are respected.\n        const alias = parse(stringPseudo);\n        return subselects[\"is\"](next, alias, options, context, compileToken);\n    }\n    if (typeof userPseudo === \"function\") {\n        verifyPseudoArgs(userPseudo, name, data, 1);\n        return (elem) => userPseudo(elem, data) && next(elem);\n    }\n    if (name in filters) {\n        return filters[name](next, data, options, context);\n    }\n    if (name in pseudos) {\n        const pseudo = pseudos[name];\n        verifyPseudoArgs(pseudo, name, data, 2);\n        return (elem) => pseudo(elem, options, data) && next(elem);\n    }\n    throw new Error(`Unknown pseudo-class :${name}`);\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}