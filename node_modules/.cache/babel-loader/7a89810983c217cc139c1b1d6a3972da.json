{"ast":null,"code":"import { ElementType } from \"domelementtype\";\nimport { Element, Text, Comment, CDATA, Document, ProcessingInstruction } from \"./node.js\";\nexport * from \"./node.js\"; // Default options\n\nconst defaultOpts = {\n  withStartIndices: false,\n  withEndIndices: false,\n  xmlMode: false\n};\nexport class DomHandler {\n  /**\n   * @param callback Called once parsing has completed.\n   * @param options Settings for the handler.\n   * @param elementCB Callback whenever a tag is closed.\n   */\n  constructor(callback, options, elementCB) {\n    /** The elements of the DOM */\n    this.dom = [];\n    /** The root element for the DOM */\n\n    this.root = new Document(this.dom);\n    /** Indicated whether parsing has been completed. */\n\n    this.done = false;\n    /** Stack of open tags. */\n\n    this.tagStack = [this.root];\n    /** A data node that is still being written to. */\n\n    this.lastNode = null;\n    /** Reference to the parser instance. Used for location information. */\n\n    this.parser = null; // Make it possible to skip arguments, for backwards-compatibility\n\n    if (typeof options === \"function\") {\n      elementCB = options;\n      options = defaultOpts;\n    }\n\n    if (typeof callback === \"object\") {\n      options = callback;\n      callback = undefined;\n    }\n\n    this.callback = callback !== null && callback !== void 0 ? callback : null;\n    this.options = options !== null && options !== void 0 ? options : defaultOpts;\n    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;\n  }\n\n  onparserinit(parser) {\n    this.parser = parser;\n  } // Resets the handler back to starting state\n\n\n  onreset() {\n    this.dom = [];\n    this.root = new Document(this.dom);\n    this.done = false;\n    this.tagStack = [this.root];\n    this.lastNode = null;\n    this.parser = null;\n  } // Signals the handler that parsing is done\n\n\n  onend() {\n    if (this.done) return;\n    this.done = true;\n    this.parser = null;\n    this.handleCallback(null);\n  }\n\n  onerror(error) {\n    this.handleCallback(error);\n  }\n\n  onclosetag() {\n    this.lastNode = null;\n    const elem = this.tagStack.pop();\n\n    if (this.options.withEndIndices) {\n      elem.endIndex = this.parser.endIndex;\n    }\n\n    if (this.elementCB) this.elementCB(elem);\n  }\n\n  onopentag(name, attribs) {\n    const type = this.options.xmlMode ? ElementType.Tag : undefined;\n    const element = new Element(name, attribs, undefined, type);\n    this.addNode(element);\n    this.tagStack.push(element);\n  }\n\n  ontext(data) {\n    const {\n      lastNode\n    } = this;\n\n    if (lastNode && lastNode.type === ElementType.Text) {\n      lastNode.data += data;\n\n      if (this.options.withEndIndices) {\n        lastNode.endIndex = this.parser.endIndex;\n      }\n    } else {\n      const node = new Text(data);\n      this.addNode(node);\n      this.lastNode = node;\n    }\n  }\n\n  oncomment(data) {\n    if (this.lastNode && this.lastNode.type === ElementType.Comment) {\n      this.lastNode.data += data;\n      return;\n    }\n\n    const node = new Comment(data);\n    this.addNode(node);\n    this.lastNode = node;\n  }\n\n  oncommentend() {\n    this.lastNode = null;\n  }\n\n  oncdatastart() {\n    const text = new Text(\"\");\n    const node = new CDATA([text]);\n    this.addNode(node);\n    text.parent = node;\n    this.lastNode = text;\n  }\n\n  oncdataend() {\n    this.lastNode = null;\n  }\n\n  onprocessinginstruction(name, data) {\n    const node = new ProcessingInstruction(name, data);\n    this.addNode(node);\n  }\n\n  handleCallback(error) {\n    if (typeof this.callback === \"function\") {\n      this.callback(error, this.dom);\n    } else if (error) {\n      throw error;\n    }\n  }\n\n  addNode(node) {\n    const parent = this.tagStack[this.tagStack.length - 1];\n    const previousSibling = parent.children[parent.children.length - 1];\n\n    if (this.options.withStartIndices) {\n      node.startIndex = this.parser.startIndex;\n    }\n\n    if (this.options.withEndIndices) {\n      node.endIndex = this.parser.endIndex;\n    }\n\n    parent.children.push(node);\n\n    if (previousSibling) {\n      node.prev = previousSibling;\n      previousSibling.next = node;\n    }\n\n    node.parent = parent;\n    this.lastNode = null;\n  }\n\n}\nexport default DomHandler;","map":{"version":3,"sources":["C:/Users/zoya/Downloads/gdsc_website-master/gdsc_website-master/node_modules/parse5-htmlparser2-tree-adapter/node_modules/domhandler/lib/esm/index.js"],"names":["ElementType","Element","Text","Comment","CDATA","Document","ProcessingInstruction","defaultOpts","withStartIndices","withEndIndices","xmlMode","DomHandler","constructor","callback","options","elementCB","dom","root","done","tagStack","lastNode","parser","undefined","onparserinit","onreset","onend","handleCallback","onerror","error","onclosetag","elem","pop","endIndex","onopentag","name","attribs","type","Tag","element","addNode","push","ontext","data","node","oncomment","oncommentend","oncdatastart","text","parent","oncdataend","onprocessinginstruction","length","previousSibling","children","startIndex","prev","next"],"mappings":"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","sourcesContent":["import { ElementType } from \"domelementtype\";\nimport { Element, Text, Comment, CDATA, Document, ProcessingInstruction, } from \"./node.js\";\nexport * from \"./node.js\";\n// Default options\nconst defaultOpts = {\n    withStartIndices: false,\n    withEndIndices: false,\n    xmlMode: false,\n};\nexport class DomHandler {\n    /**\n     * @param callback Called once parsing has completed.\n     * @param options Settings for the handler.\n     * @param elementCB Callback whenever a tag is closed.\n     */\n    constructor(callback, options, elementCB) {\n        /** The elements of the DOM */\n        this.dom = [];\n        /** The root element for the DOM */\n        this.root = new Document(this.dom);\n        /** Indicated whether parsing has been completed. */\n        this.done = false;\n        /** Stack of open tags. */\n        this.tagStack = [this.root];\n        /** A data node that is still being written to. */\n        this.lastNode = null;\n        /** Reference to the parser instance. Used for location information. */\n        this.parser = null;\n        // Make it possible to skip arguments, for backwards-compatibility\n        if (typeof options === \"function\") {\n            elementCB = options;\n            options = defaultOpts;\n        }\n        if (typeof callback === \"object\") {\n            options = callback;\n            callback = undefined;\n        }\n        this.callback = callback !== null && callback !== void 0 ? callback : null;\n        this.options = options !== null && options !== void 0 ? options : defaultOpts;\n        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;\n    }\n    onparserinit(parser) {\n        this.parser = parser;\n    }\n    // Resets the handler back to starting state\n    onreset() {\n        this.dom = [];\n        this.root = new Document(this.dom);\n        this.done = false;\n        this.tagStack = [this.root];\n        this.lastNode = null;\n        this.parser = null;\n    }\n    // Signals the handler that parsing is done\n    onend() {\n        if (this.done)\n            return;\n        this.done = true;\n        this.parser = null;\n        this.handleCallback(null);\n    }\n    onerror(error) {\n        this.handleCallback(error);\n    }\n    onclosetag() {\n        this.lastNode = null;\n        const elem = this.tagStack.pop();\n        if (this.options.withEndIndices) {\n            elem.endIndex = this.parser.endIndex;\n        }\n        if (this.elementCB)\n            this.elementCB(elem);\n    }\n    onopentag(name, attribs) {\n        const type = this.options.xmlMode ? ElementType.Tag : undefined;\n        const element = new Element(name, attribs, undefined, type);\n        this.addNode(element);\n        this.tagStack.push(element);\n    }\n    ontext(data) {\n        const { lastNode } = this;\n        if (lastNode && lastNode.type === ElementType.Text) {\n            lastNode.data += data;\n            if (this.options.withEndIndices) {\n                lastNode.endIndex = this.parser.endIndex;\n            }\n        }\n        else {\n            const node = new Text(data);\n            this.addNode(node);\n            this.lastNode = node;\n        }\n    }\n    oncomment(data) {\n        if (this.lastNode && this.lastNode.type === ElementType.Comment) {\n            this.lastNode.data += data;\n            return;\n        }\n        const node = new Comment(data);\n        this.addNode(node);\n        this.lastNode = node;\n    }\n    oncommentend() {\n        this.lastNode = null;\n    }\n    oncdatastart() {\n        const text = new Text(\"\");\n        const node = new CDATA([text]);\n        this.addNode(node);\n        text.parent = node;\n        this.lastNode = text;\n    }\n    oncdataend() {\n        this.lastNode = null;\n    }\n    onprocessinginstruction(name, data) {\n        const node = new ProcessingInstruction(name, data);\n        this.addNode(node);\n    }\n    handleCallback(error) {\n        if (typeof this.callback === \"function\") {\n            this.callback(error, this.dom);\n        }\n        else if (error) {\n            throw error;\n        }\n    }\n    addNode(node) {\n        const parent = this.tagStack[this.tagStack.length - 1];\n        const previousSibling = parent.children[parent.children.length - 1];\n        if (this.options.withStartIndices) {\n            node.startIndex = this.parser.startIndex;\n        }\n        if (this.options.withEndIndices) {\n            node.endIndex = this.parser.endIndex;\n        }\n        parent.children.push(node);\n        if (previousSibling) {\n            node.prev = previousSibling;\n            previousSibling.next = node;\n        }\n        node.parent = parent;\n        this.lastNode = null;\n    }\n}\nexport default DomHandler;\n"]},"metadata":{},"sourceType":"module"}