{"ast":null,"code":"import { isTag, hasChildren } from \"domhandler\";\n/**\n * Get a node's children.\n *\n * @category Traversal\n * @param elem Node to get the children of.\n * @returns `elem`'s children, or an empty array.\n */\n\nexport function getChildren(elem) {\n  return hasChildren(elem) ? elem.children : [];\n}\n/**\n * Get a node's parent.\n *\n * @category Traversal\n * @param elem Node to get the parent of.\n * @returns `elem`'s parent node.\n */\n\nexport function getParent(elem) {\n  return elem.parent || null;\n}\n/**\n * Gets an elements siblings, including the element itself.\n *\n * Attempts to get the children through the element's parent first. If we don't\n * have a parent (the element is a root node), we walk the element's `prev` &\n * `next` to get all remaining nodes.\n *\n * @category Traversal\n * @param elem Element to get the siblings of.\n * @returns `elem`'s siblings.\n */\n\nexport function getSiblings(elem) {\n  const parent = getParent(elem);\n  if (parent != null) return getChildren(parent);\n  const siblings = [elem];\n  let {\n    prev,\n    next\n  } = elem;\n\n  while (prev != null) {\n    siblings.unshift(prev);\n    ({\n      prev\n    } = prev);\n  }\n\n  while (next != null) {\n    siblings.push(next);\n    ({\n      next\n    } = next);\n  }\n\n  return siblings;\n}\n/**\n * Gets an attribute from an element.\n *\n * @category Traversal\n * @param elem Element to check.\n * @param name Attribute name to retrieve.\n * @returns The element's attribute value, or `undefined`.\n */\n\nexport function getAttributeValue(elem, name) {\n  var _a;\n\n  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];\n}\n/**\n * Checks whether an element has an attribute.\n *\n * @category Traversal\n * @param elem Element to check.\n * @param name Attribute name to look for.\n * @returns Returns whether `elem` has the attribute `name`.\n */\n\nexport function hasAttrib(elem, name) {\n  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;\n}\n/**\n * Get the tag name of an element.\n *\n * @category Traversal\n * @param elem The element to get the name for.\n * @returns The tag name of `elem`.\n */\n\nexport function getName(elem) {\n  return elem.name;\n}\n/**\n * Returns the next element sibling of a node.\n *\n * @category Traversal\n * @param elem The element to get the next sibling of.\n * @returns `elem`'s next sibling that is a tag.\n */\n\nexport function nextElementSibling(elem) {\n  let {\n    next\n  } = elem;\n\n  while (next !== null && !isTag(next)) ({\n    next\n  } = next);\n\n  return next;\n}\n/**\n * Returns the previous element sibling of a node.\n *\n * @category Traversal\n * @param elem The element to get the previous sibling of.\n * @returns `elem`'s previous sibling that is a tag.\n */\n\nexport function prevElementSibling(elem) {\n  let {\n    prev\n  } = elem;\n\n  while (prev !== null && !isTag(prev)) ({\n    prev\n  } = prev);\n\n  return prev;\n}","map":{"version":3,"sources":["traversal.ts"],"names":[],"mappings":"AAAA,SACI,KADJ,EAMI,WANJ,QAOO,YAPP;AASA;;;;;;AAMG;;AACH,OAAM,SAAU,WAAV,CAAsB,IAAtB,EAAmC;AACrC,SAAO,WAAW,CAAC,IAAD,CAAX,GAAoB,IAAI,CAAC,QAAzB,GAAoC,EAA3C;AACH;AAGD;;;;;;AAMG;;AACH,OAAM,SAAU,SAAV,CAAoB,IAApB,EAAiC;AACnC,SAAO,IAAI,CAAC,MAAL,IAAe,IAAtB;AACH;AAED;;;;;;;;;;AAUG;;AACH,OAAM,SAAU,WAAV,CAAsB,IAAtB,EAAmC;AACrC,QAAM,MAAM,GAAG,SAAS,CAAC,IAAD,CAAxB;AACA,MAAI,MAAM,IAAI,IAAd,EAAoB,OAAO,WAAW,CAAC,MAAD,CAAlB;AAEpB,QAAM,QAAQ,GAAG,CAAC,IAAD,CAAjB;AACA,MAAI;AAAE,IAAA,IAAF;AAAQ,IAAA;AAAR,MAAiB,IAArB;;AACA,SAAO,IAAI,IAAI,IAAf,EAAqB;AACjB,IAAA,QAAQ,CAAC,OAAT,CAAiB,IAAjB;AACA,KAAC;AAAE,MAAA;AAAF,QAAW,IAAZ;AACH;;AACD,SAAO,IAAI,IAAI,IAAf,EAAqB;AACjB,IAAA,QAAQ,CAAC,IAAT,CAAc,IAAd;AACA,KAAC;AAAE,MAAA;AAAF,QAAW,IAAZ;AACH;;AACD,SAAO,QAAP;AACH;AAED;;;;;;;AAOG;;AACH,OAAM,SAAU,iBAAV,CACF,IADE,EAEF,IAFE,EAEU;;;AAEZ,SAAO,CAAA,EAAA,GAAA,IAAI,CAAC,OAAL,MAAY,IAAZ,IAAY,EAAA,KAAA,KAAA,CAAZ,GAAY,KAAA,CAAZ,GAAY,EAAA,CAAG,IAAH,CAAnB;AACH;AAED;;;;;;;AAOG;;AACH,OAAM,SAAU,SAAV,CAAoB,IAApB,EAAmC,IAAnC,EAA+C;AACjD,SACI,IAAI,CAAC,OAAL,IAAgB,IAAhB,IACA,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,IAAI,CAAC,OAA1C,EAAmD,IAAnD,CADA,IAEA,IAAI,CAAC,OAAL,CAAa,IAAb,KAAsB,IAH1B;AAKH;AAED;;;;;;AAMG;;AACH,OAAM,SAAU,OAAV,CAAkB,IAAlB,EAA+B;AACjC,SAAO,IAAI,CAAC,IAAZ;AACH;AAED;;;;;;AAMG;;AACH,OAAM,SAAU,kBAAV,CAA6B,IAA7B,EAA0C;AAC5C,MAAI;AAAE,IAAA;AAAF,MAAW,IAAf;;AACA,SAAO,IAAI,KAAK,IAAT,IAAiB,CAAC,KAAK,CAAC,IAAD,CAA9B,EAAsC,CAAC;AAAE,IAAA;AAAF,MAAW,IAAZ;;AACtC,SAAO,IAAP;AACH;AAED;;;;;;AAMG;;AACH,OAAM,SAAU,kBAAV,CAA6B,IAA7B,EAA0C;AAC5C,MAAI;AAAE,IAAA;AAAF,MAAW,IAAf;;AACA,SAAO,IAAI,KAAK,IAAT,IAAiB,CAAC,KAAK,CAAC,IAAD,CAA9B,EAAsC,CAAC;AAAE,IAAA;AAAF,MAAW,IAAZ;;AACtC,SAAO,IAAP;AACH","sourceRoot":"https://raw.githubusercontent.com/fb55/domutils/f7e357b5c210b6731c2a60e0b7b3cfaa1f96b706/src/","sourcesContent":["import { isTag, hasChildren, } from \"domhandler\";\n/**\n * Get a node's children.\n *\n * @category Traversal\n * @param elem Node to get the children of.\n * @returns `elem`'s children, or an empty array.\n */\nexport function getChildren(elem) {\n    return hasChildren(elem) ? elem.children : [];\n}\n/**\n * Get a node's parent.\n *\n * @category Traversal\n * @param elem Node to get the parent of.\n * @returns `elem`'s parent node.\n */\nexport function getParent(elem) {\n    return elem.parent || null;\n}\n/**\n * Gets an elements siblings, including the element itself.\n *\n * Attempts to get the children through the element's parent first. If we don't\n * have a parent (the element is a root node), we walk the element's `prev` &\n * `next` to get all remaining nodes.\n *\n * @category Traversal\n * @param elem Element to get the siblings of.\n * @returns `elem`'s siblings.\n */\nexport function getSiblings(elem) {\n    const parent = getParent(elem);\n    if (parent != null)\n        return getChildren(parent);\n    const siblings = [elem];\n    let { prev, next } = elem;\n    while (prev != null) {\n        siblings.unshift(prev);\n        ({ prev } = prev);\n    }\n    while (next != null) {\n        siblings.push(next);\n        ({ next } = next);\n    }\n    return siblings;\n}\n/**\n * Gets an attribute from an element.\n *\n * @category Traversal\n * @param elem Element to check.\n * @param name Attribute name to retrieve.\n * @returns The element's attribute value, or `undefined`.\n */\nexport function getAttributeValue(elem, name) {\n    var _a;\n    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];\n}\n/**\n * Checks whether an element has an attribute.\n *\n * @category Traversal\n * @param elem Element to check.\n * @param name Attribute name to look for.\n * @returns Returns whether `elem` has the attribute `name`.\n */\nexport function hasAttrib(elem, name) {\n    return (elem.attribs != null &&\n        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&\n        elem.attribs[name] != null);\n}\n/**\n * Get the tag name of an element.\n *\n * @category Traversal\n * @param elem The element to get the name for.\n * @returns The tag name of `elem`.\n */\nexport function getName(elem) {\n    return elem.name;\n}\n/**\n * Returns the next element sibling of a node.\n *\n * @category Traversal\n * @param elem The element to get the next sibling of.\n * @returns `elem`'s next sibling that is a tag.\n */\nexport function nextElementSibling(elem) {\n    let { next } = elem;\n    while (next !== null && !isTag(next))\n        ({ next } = next);\n    return next;\n}\n/**\n * Returns the previous element sibling of a node.\n *\n * @category Traversal\n * @param elem The element to get the previous sibling of.\n * @returns `elem`'s previous sibling that is a tag.\n */\nexport function prevElementSibling(elem) {\n    let { prev } = elem;\n    while (prev !== null && !isTag(prev))\n        ({ prev } = prev);\n    return prev;\n}\n//# sourceMappingURL=traversal.js.map"]},"metadata":{},"sourceType":"module"}